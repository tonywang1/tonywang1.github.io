{"meta":{"title":"雪地行人","subtitle":null,"description":"纷繁的大雪中驻立着的雪人","author":"Tony Wang","url":"https://tonywang1.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2019-08-29T15:48:13.000Z","updated":"2019-08-30T02:34:26.785Z","comments":false,"path":"categories/index.html","permalink":"https://tonywang1.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章标签分类","date":"2019-08-29T17:10:14.000Z","updated":"2019-08-30T02:34:03.665Z","comments":false,"path":"tags/index.html","permalink":"https://tonywang1.github.io/tags/index.html","excerpt":"","text":""},{"title":"test2","date":"2019-08-29T10:29:19.000Z","updated":"2019-08-29T02:29:19.551Z","comments":true,"path":"test2/index.html","permalink":"https://tonywang1.github.io/test2/index.html","excerpt":"","text":""},{"title":"test1","date":"2019-08-29T10:28:55.000Z","updated":"2019-08-29T02:28:55.505Z","comments":true,"path":"test1/index.html","permalink":"https://tonywang1.github.io/test1/index.html","excerpt":"","text":""}],"posts":[{"title":"maven浅尝辄止1","slug":"2019/09/17/maven浅尝辄止","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-23T12:31:33.056Z","comments":true,"path":"2019/09/18/maven1/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/maven1/","excerpt":"","text":"maven浅尝辄止1 1.什么是maven？ Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。参考 2. maven能帮我们解决什么问题 项目统一构建 - 统一生成项目结构 jar包统一管理 - 自动下载jar包、对应的jar包的依赖、jar包不同版本冲突问题、jar包版本统一管理 项目版本统一管理 - Release和SNAPSHOT版本即稳定版本和快照版本 项目的编译、测试、打包 、安装、发布等管理 项目不同环境配置的管理 不同项目之间依赖管理 3. maven中如何使用profile来解决项目不同环境的问题profile使用原理：通过激活某个profile来加载对应的属性，达到不同环境加载不同属性作用 1、命令激活：通过打包的时候使用 -p profile名称指定该profile对应的环境的变量2、属性加载：不同profile定义不同属性或者加载不同的属性文件-代码3.13、属性引用：在2中定义的属性或者加载的属性文件的内容可以通过${定义的属性名称}引用4、属性文件赋值：利用2中加载属性与resource中的filter连用，达到对属性文件赋值的作用，即代码2中的属性文件中所有带有${定义的属性名称}引用的变量，在编译阶段都会用实际的属性代替，代码3.2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051代码3.1&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 默认激活开发配制，使用config-dev.properties来替换设置过虑的资源文件中的$&#123;key&#125; --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-dev.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-test.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-prod.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;``` ``` xml*** 代码3.2-这里filtering属性=true代表所有资源文件中带有placehoder的变量都会用maven的便来给你代替 ***&lt;resources&gt; &lt;!-- Resource Filter --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 4. maven中如何使用resource打不同的资源文件来解决不同环境问题 默认属性文件目录处理：根据profile属性拼接并打包对应的配置文件如代码4.1 源文件目录下配置文件处理：拷贝java源文件目录下的配置文件 1234567891011121314151617181920212223代码4.1&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;excludes&gt; &lt;exclude&gt;application.properties&lt;/exclude&gt; &lt;exclude&gt;application-dev.properties&lt;/exclude&gt; &lt;exclude&gt;application-test.properties&lt;/exclude&gt; &lt;exclude&gt;application-prod.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;application.properties&lt;/include&gt; &lt;include&gt;application-$&#123;profiles.active&#125;.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt;&lt;/resources&gt; 123456789101112131415161718192021代码4.2&lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，只处理如下配置中包含的资源类型 --&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，不处理如下配置中包含的资源类型（剔除下如下配置中包含的资源类型）--&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.yaml&lt;/exclude&gt; &lt;/excludes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，指定处理后的资源文件输出目录，默认是$&#123;build.outputDirectory&#125;指定的目录--&gt; &lt;!--&lt;targetPath&gt;$&#123;build.outputDirectory&#125;&lt;/targetPath&gt; --&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，是否对主资源目录开启资源过滤 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; 4. maven中父子项目依赖关系父子项目依赖的多模块处理作用: 复杂项目通过合理拆分达到代码复用、方便管理 父项目设置-如代码4.1 packaging=pommodules中包含所有子项目，里面的名字为各个项目的artifactId参数 子项目设置-如代码4.2，里面的参数为父项目的相应值，子项目不指定groupId，会自动从父项目中继承 子项目之家可以通过dependency来进行引用 123456789代码4.1&lt;packaging&gt;pom&lt;/packaging&gt;&lt;modules&gt; &lt;module&gt;pojo&lt;/module&gt; &lt;module&gt;web&lt;/module&gt; &lt;module&gt;dao&lt;/module&gt; &lt;module&gt;service&lt;/module&gt;&lt;/modules&gt; 123456代码4.2&lt;parent&gt; &lt;artifactId&gt;online_retailers&lt;/artifactId&gt; &lt;groupId&gt;com.hd&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 5.maven中必要节点的作用说明 filters：定义指定filter属性的位置，例如filter元素赋值filters/filter1.properties,那么这个文件里面就可以定义name=value对，这个name=value对的值就可以在工程pom中通过${name}引用，默认的filter目录是${basedir}/src/main/fiters/ packing：主要打什么类型的包-pom、jar(默认)、war pom - 父类型都为pom jar - 内部调用或者服务使用 war - 部署的项目 modelVersion:模型版本，暂时固定为4.0.0 groupId： 1 项目构建的时候第一次会根据这个参数构建目录2 打包后jar位置为：repository后面的目录为-groupId所设置的目录 、在后面为artifactId，在后面为版本version ，所以groupId+artifactId+version决定了jar包的位置 artifactId：项目的唯一ID version：版本号，分release和snapshot版本 name:项目的显示名称，idea的maven视图中会显示这个名称 6. maven中内置的属性变量内置属性(Maven预定义,用户可以直接使用) ${basedir}表示项目根目录,即包含pom.xml文件的目录; ${version}表示项目版本; ${project.basedir}同${basedir}; ${project.baseUri}表示项目文件地址; ${maven.build.timestamp}表示项目构件开始时间; POM属性 ${project.build.directory}表示主源码路径 ${project.build.sourceEncoding}表示主源码的编码格式 ${project.build.sourceDirectory}表示主源码路径 ${project.build.finalName}表示输出文件名称 ${project.version}表示项目版本,与${version}相同 Java系统属性(所有的Java系统属性都可以使用Maven属性引用) 使用mvn help:system命令可查看所有的Java系统属性; System.getProperties()可得到所有的Java属性; ${user.home}表示用户目录 环境变量属性(所有的环境变量都可以用以env.开头的Maven属性引用) -使用mvn help:system命令可查看所有环境变量; ${env.JAVA_HOME}表示JAVA_HOME环境变量的值; 8.maven的生命周期，以及执行规则1） 生命周期 Maven有三个独立的生命周期为：clean-项目清理、default-项目构建、site-站点生成 2）生命周期对应的阶段clean生命周期包含三个阶段 pre-clean：执行一些需要在clean之前完成的工作 clean：移除所有上一次构建生成的文件 post-clean：执行一些需要在clean之后立刻完成的工作 default生命周期的阶段列表： validate：验证 initialize：initialize build state, e.g. set properties or create directories. generate-sources：generate any source code for inclusion in compilation. process-sources：process the source code, for example to filter any values. generate-resources：处理资源文件 process-resources：复制并处理资源文件，至目标目录，准备打包 compile：编译项目源代码 process-classes：post-process the generated files from compilation, for example to do bytecode enhancement on Java classes. generate-test-sources：generate any test source code for inclusion in compilation. process-test-sources：process the test source code, for example to filter any values. generate-test-resources create resources for testing. process-test-resources 复制并处理资源文件，至目标测试目录 test-compile 编译测试源代码 process-test-classes： post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above. test：使用合适的单元测试框架运行测试，这些测试代码不会被打包或者部署。 prepare-package：perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above) package：接受编译好的代码，打包成可发布的格式，如jar pre-integration-test：perform actions required before integration tests are executed. This may involve things such as setting up the required environment. integration-test：process and deploy the package if necessary into an environment where integration tests can be run. post-integration-test：perform actions required after integration tests have been executed. This may including cleaning up the environment. verify run any checks to verify the package is valid and meets quality criteria. install：将包安装至本地仓库，以让其他项目依赖 deploy 3) 生命周期中阶段的执行关系 某个特定生命周期中，生命周期后面的阶段执行，都会伴随着前面阶段的执行 不同生命周期之间不依赖 4）生命周期、阶段、插件关系一个生命周期中有多个阶段，一个阶段可以绑定一个或者多个插件 9.SNAPSHOT版本和release版本区别 Release版本则代表稳定的版本 只要版本不变，则打包的时候会用本地库中的版本，不会去远程服务器上更新。 Snapshot版本代表不稳定、尚处于开发中的版本 项目每次构建的时候，Maven会去远程repository下载snapshot的最新版本，如果被依赖的snapshot版本不断更新，则项目每次构建的时候的结果都会不一样 10.依赖包的scope取值说明 compile，缺省值，适用于所有阶段，会随着项目一起发布。 provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 11.自定义属性使用标签“properties”中定义的属性","categories":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/categories/MAVEN/"}],"tags":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/tags/MAVEN/"}]},{"title":"深入字节","slug":"深入字节","date":"2019-09-10T20:32:15.000Z","updated":"2019-09-17T07:36:10.853Z","comments":true,"path":"2019/09/11/lean_byte/","link":"","permalink":"https://tonywang1.github.io/2019/09/11/lean_byte/","excerpt":"","text":"深入了解字节 1.为什么要写字节这个东东 做JAVA项目的时候总会碰到读写字节的过程 经常有字符串和字节互相转化的过程 每次只是知道怎么做，但是不知道为什么这样做 希望经过这篇文章整理，彻底了解这个字节以及字节和用户输入文字之间的关系。 2. 了解一下具体什么是字节 在编程的时候总会遇到字节数组，如读取一个文件时候多个字节一起读、Socket的网络编程的时候读取数据也是按照字节读取的，总会思考这个字节是什么？ 答案：字节实际上就是我们在换算单位时候用到的byte，一个byte=8位（八个0、1组成的一串二进制的数字） 3. 在java中字符串是如何转化为字节的计算机起源美国 -&gt; 美国使用英语 -&gt; 英语（数字、大小写字母、控制字符标点符号、运算字符等组成） -&gt; 8位二进制数（共255个）表示所有字符即：你每次输入一个字符-计算机会到对照表中查找对应的值(二进制、十进制) -&gt; 二进制就可以被计算机识别到此计算机可以识别人类输入的所有英文字符 -&gt; 即字符到二进制的转换 问题出现 -&gt; 非英语字符通过对照表找不到对应的值，就不能识别如何处理对应的字符，如：输入中文“您”，到对照表中找不到，计算机就不认识。那么，就需要有其他的对照表出现：即gb2312、gbk、utf-8等 一个中文转换成字符的过程是怎么样子的？ 字符：‘我’-utf-8编码-&gt;BDE4-&gt;251059（十进制）-&gt;6211（十六进制）-&gt; 1100111011010010 (二进制) ‘中’-&gt;对应的Unicode表的值4E2D（十六进制）（java使用Unicode编码）-&gt;对应的二进制100111000101101-&gt;utf-8填充规则转换-&gt;11100100 10111000 10101101 UTF-8最多可用到6个字节则二进制变为100 111000 101101一共3个部分参考链接 4. 对于计算机的深入思考计算机终究只认识两个东西0、1,但是计算机要处理的是人类的输入并且最后要输出的东西也是要给人类使用的，这时候计算机要处理以下问题 接受人类输入的文字 把字符转化为自己能识别的0和1 对转化过的数据进行二进制之间的计算 对最终的计算结果进行编码成为用户可见的文字并呈现给使用者 其中把人类输入文字转换为0和1,和最终转换为用户可见的文字过程需要使用字符编码 解码:计算机识别的对应编码的二进制数字，按照编码格式转化为统一的编码格式，然后到编码表中找到对应的文字 编码：文字根据编码表找到对应的数值，然后转换为UNIQUE编码的二进制，在转换为工程对应的编码的二进制格式数据","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"一次读取配置文件的探究","slug":"2019/09/09/属性文件读取问题","date":"2019-09-09T17:51:03.000Z","updated":"2019-09-10T12:16:35.565Z","comments":true,"path":"2019/09/10/read_config/","link":"","permalink":"https://tonywang1.github.io/2019/09/10/read_config/","excerpt":"","text":"一次读取配置文件的探究 1. 问题的获取 用App.class.getResourceAsStream(fileName)找不到配置文件，然后去看了一遍源码，发现App.class.getClassLoader().getResourceAsStream代码是有区别的，整理如下： 2. class.getResourceAsStream(fileName)说明 相对路径：如果fileName不是用“/”开头的，则程序会找到Test这个类对应的目录去查找filename类 绝对路径：如果fileName用“/”开头的，则程序会直接从根目录查找对应的文件去加载 详细可以查看源码Class.java 中方法getResourceAsStream 12具体为Class 中的 getResourceAsStream中的方法可以查看详细：resolveName(name) 3.classLoader.getResourceAsStream() 是从类的根目录查找对应的文件，与当前的类路径无关 class中读取配置文件的方法也调用的这个方法 寻找资源文件的时候调用ClassLoader中方法getResource查找 具体查找文件方式为类加载器的双亲委托机制 4. ClassLoader查找文件规则双亲委托模型相关 从根类加载器关联的路径找对应的文件1根类加载器对应的文件路径：String bootClassPath = System.getProperty(&quot;sun.boot.class.path&quot;); 2 . 从扩展类加载器查找文件 1扩展类加载器对应路径：System.out.println(&quot;ext:&quot;+System.getProperty(&quot;java.ext.dirs&quot;)); 3 . 从应用类加载器-这部分包括我们自己项目的目录下所有的jar包和文件 1System.out.println(&quot;app:&quot;+System.getProperty(&quot;java.class.path&quot;)); 5. 那么三种加载器的属性文件在哪里设置的呢？ 所有系统属性可以通过下面的代码获取到，但是具体在什么地方设置的一直没有找到，留到以后探究吧。 1打印java所有的系统环境变量：java.util.Properties properties = System.getProperties();","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"Github上创建自己的网站","slug":"2019/08/30/Github创建网站","date":"2019-08-30T17:51:03.000Z","updated":"2019-08-30T10:54:32.718Z","comments":true,"path":"2019/08/31/gen_github_page/","link":"","permalink":"https://tonywang1.github.io/2019/08/31/gen_github_page/","excerpt":"","text":"Github搭建自己的博客 为什么要搭建自己的博客 探索未知世界 记录自己的成长 为后来者提供借鉴 梳理自己的逻辑思维 整理自己的学习知识，方便以后查阅 1. github page是什么？ GitHub页面是一种静态网站托管服务，旨在直接从GitHub存储库托管个人、组织或项目页面。 Github Page官方详细 2. hexo是什么？ 简单、快速、强大的Node.js静态博客框架 hexo源码 hexo官方网站 3. github page的设置 设置GitHubPage 个人操作借鉴 （详细请参考上文超链接） 创建一个repository，名称为（用户名 + .github.io ）括号中的以后是你博客的默认域名 切换tab到setting，并设置Repository name 4. nodejs、hexo安装，git安装nodejs的安装，直接百度就可以搜索到，直接下载安装非常简单git安装hexo安装参考 5. 创建、清理、发布、启动服务、本地访问文档地址 创建静态站点 hexo init 创建一个文章 hexo new [layout] &lt;title&gt; 生成静态文件 hexo generate 启动服务 hexo server 部署网站 hexo deploy 清除缓存和生成的静态文件 hexo clean 项目本地启动以后可以访问 http://localhost:4000/ 6. 步骤5中创建的项目与Git关联并上传到git仓库 git init git add . git commit &#39;评论&#39; 本地项目关联到git上：git remote add origin &lt;server&gt; 7. 更换主题 到 主题源码 页面fork源码到我们自己git上 主题安装 点击查看文档 修改配置文件（_config.yml）添加 theme: indigo指定主题 我用的indigo主题源码 8. hexo选择修改语言类型 现在项目还是英文的，需要修改项目的语言为中文 修改配置文件（_config.yml）中 language: zh-CN 6. hexo布局的使用 scaffolds文件夹中有3个文件分别为draft.md、page.md、post.md分别对应草稿、page格式、post格式的文件模板 命令 hexo new [layout] &lt;title&gt; 中的layout取值为：draft、page、post 三个文件中的Front-matter中可以放一些变量在里面，以便生成静态页面的时候可以使用 12345678这里是我自己搭建项目的模板 其中urlname这个变量设置以后生成的静态文件路径上会使用---title: &#123;&#123; title &#125;&#125;urlname: date: &#123;&#123; date &#125;&#125;tags:categories:--- 7. hexo生成静态页面的目录的设置配置文件_config.yml中设置下面的permalink参数，生成静态页面的访问路径，会根据Front-matter中的变量设置参数permalink: :year/:month/:day/:urlname/ 8. hexo标签和分类的使用，以及标签和分类区别分类生成及使用 打开命令行，进入博客所在文件夹。执行命令hexo new page categories 会生成一个文件 ，/categories/index.md 修改分类中的设置如下，有的版本使用type有的版本使用layout变量 1234567---title: 文章分类date: 2019-08-29 15:48:13comments: falsetype: categorieslayout: categories--- 写文章的收需要加上 categories: “文章标签名称” 原理：hexo 会找到layout: categories的设置，然后搜索所有文章中有categories设置的分类，生成分类列表 标签生成及使用操作： 打开命令行，进入博客所在文件夹。执行命令`hexo new page tags 下面的设置和categories一样了","categories":[{"name":"Github","slug":"Github","permalink":"https://tonywang1.github.io/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://tonywang1.github.io/tags/Github/"}]},{"title":"test1","slug":"test1","date":"2019-08-29T10:28:45.000Z","updated":"2019-08-29T02:28:45.788Z","comments":true,"path":"2019/08/29/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/29/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"test10","slug":"2019-8-29/test10","date":"2019-08-29T10:27:50.000Z","updated":"2019-08-30T06:28:44.938Z","comments":true,"path":"2019/08/29/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/29/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-28T07:50:32.729Z","updated":"2019-08-28T07:50:32.729Z","comments":true,"path":"2019/08/28/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/28/index/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}