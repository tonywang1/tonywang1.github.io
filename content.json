{"meta":{"title":"雪地行人","subtitle":null,"description":"纷繁的大雪中驻立着的雪人","author":"Tony Wang","url":"https://tonywang1.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2019-08-29T15:48:13.000Z","updated":"2019-08-30T02:34:26.785Z","comments":false,"path":"categories/index.html","permalink":"https://tonywang1.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章标签分类","date":"2019-08-29T17:10:14.000Z","updated":"2019-08-30T02:34:03.665Z","comments":false,"path":"tags/index.html","permalink":"https://tonywang1.github.io/tags/index.html","excerpt":"","text":""},{"title":"test1","date":"2019-08-29T10:28:55.000Z","updated":"2019-08-29T02:28:55.505Z","comments":true,"path":"test1/index.html","permalink":"https://tonywang1.github.io/test1/index.html","excerpt":"","text":""},{"title":"test2","date":"2019-08-29T10:29:19.000Z","updated":"2019-08-29T02:29:19.551Z","comments":true,"path":"test2/index.html","permalink":"https://tonywang1.github.io/test2/index.html","excerpt":"","text":""}],"posts":[{"title":"linux中脚本介绍","slug":"2020/linux/linux-shell_bak","date":"2020-04-11T15:41:13.000Z","updated":"2020-04-23T11:43:13.456Z","comments":true,"path":"2020/04/11/linux_shell/","link":"","permalink":"https://tonywang1.github.io/2020/04/11/linux_shell/","excerpt":"","text":"日志清理脚本12345678910111213141516#!/bin/bash#统计一定数量的日志，然后根据时间删除logpath=\"/data/tomcat/logs\"count=`find /data/tomcat/logs -name \"*.log\" -o -name \"*.txt\" -type f -mtime +3 | wc -l`echo \"$count\";if [ \"$count\" -lt \"20\" ];then echo \"file is less 20. no file is removed.\" exit 0;fi#find $logpath -name \"*.log\" -o -name \"*.txt\" -type f -mtime +5 -exec rm &#123;&#125; \\; &gt; /dev/null 2&gt;&amp;1 ;find /data/tomcat/logs -name \"*.log\" -mtime +3 -exec rm &#123;&#125; \\; find /data/tomcat/logs -name \"*.txt\" -mtime +3 -exec rm &#123;&#125; \\;count2=` find /data/tomcat/logs -name \"*.log\" -o -name \"*.txt\" -type f -mtime +10 | wc -l`echo \"$count2\" 2、JAVA项目启动脚本123456#!/bin/bashecho &quot;杀掉springboot线程&quot;pgrep -f 项目名称|xargs kill -9echo &quot;项目启动&quot;nohup java -server -Xms1096m -Xmx1096m -jar 项目的.jar &gt; out.log 2&gt;&amp;1 &amp;tail -f -n500 out.log 3、服务的启动关闭脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/bin/bashstart() &#123; source /etc/profile cd /usr/local/source/kong make install /usr/local/openresty/bin/kong start cd /&#125; stop() &#123; source /etc/profile kong stop&#125;reload() &#123; source /etc/profile cd /usr/local/source/kong make install /usr/local/openresty/bin/kong start cd /&#125;status()&#123; if test $( pgrep -f nginx | wc -l ) -eq 0; then echo &quot;is not running&quot; else echo &quot;is running&quot; fi #count=`ps -ef |grep nginx |grep -v &quot;grep&quot; |wc -l` #if [ 0 == $count ];then # echo &quot;is not running&quot; #else # echo &quot;is running&quot; #fi&#125; case $1 in start) start ;; stop) stop ;; restart) reload ;; status) status exit $? ;; kill) terminate ;; *) echo -e &quot;no parameter&quot; ;;esac exit 0","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/categories/LINUX/"}],"tags":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/tags/LINUX/"}]},{"title":"ES初识","slug":"2020/server/es-use","date":"2020-04-11T15:41:13.000Z","updated":"2020-07-18T07:09:22.208Z","comments":true,"path":"2020/04/11/es-use/","link":"","permalink":"https://tonywang1.github.io/2020/04/11/es-use/","excerpt":"","text":"ES初识1、什么是ES，能解决什么问题 分布式搜索分析引擎，可以提供近实时的搜索，分析，存储功能 2、ES主要的使用场景是什么？ 搜索、分析、日志、Kibana整合进行可视化图标统计等##3 主要的关键字解释 文档：document -我们存储的数据，数据存储到索引中，会被分词以倒排索引的形式存储。 索引-index ：文档的数据集合 type 映射-mapping：即数据存储模板，决定了数据存到索引中以后的行为，如是否需要分词，使用什么分词等。 查看已经添加的模板信息：GET _template/模板名称 定义映射的时候要确定：字段是否需要全文索引，还是准确的查找，是否需要单独的分词，一段文字可以根据不同使用情况，存储多个key中，是否需要自定义数据类型 分词：各种分词插件，搜索和存储的时候会用到##4下面是数据查询文档的整理： 下面是数据查询文档的整理：1 搜索 wildcard-通配符 ： https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html exists-值是否存在：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html fuzzy-相似模糊：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html prefix-前缀：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html range-范围：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html term-字段匹配：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html terms-字段in匹配：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html terms-set - 集合子集匹配：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-set-query.html Match-all-全集合查询：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html Mathch-全文检索：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html Mathch-Phrase - 短语全文检索：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html Bool - 组合查询：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html boosting-得分分配：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html Query与Filter区别：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html 2 组合统计 AVG-平均数：https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-avg-aggregation.html MAX-最大值：https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-max-aggregation.html MIN-最小值：https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-min-aggregation.html Stat-最大最小平均数：https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-stats-aggregation.html、 Sum-求和：https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-sum-aggregation.html 分组统计：https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html 先过滤在统计：https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filter-aggregation.html 数据类型：https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html 自带元数据：https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html 创建索引：https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html 创建mapping: https://www.elastic.co/guide/en/elasticsearch/reference/current/properties.html 创建mapping：https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html 更新查看mapping：https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html#update-mapping 3 java api的入口 api：https://www.elastic.co/guide/en/elasticsearch/client/index.html 创建索引：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-index.html Get请求：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-get.html 是否存在搜索内容：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-exists.html 批量执行：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-bulk.html 搜索：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-search.html 4 分片优化方案分片优化方案： 1、从集群总内存上去看集群一共支持多少分片- 最大分片数量=集群总内存*20 2、从索引大小的角度看，索引中每个分片占用磁盘大小，小于50G如果按照天计算索引，每个索引大小为1T，则分片 数量=(1T*1024)/30，当然分母为30和50中间的值 3、节点数量上，一个索引分片大小在，节点数量的1.5到3倍的原则 4、1个索引最好不要超过21亿的文档分片官方文档：https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster","categories":[{"name":"中间件","slug":"中间件","permalink":"https://tonywang1.github.io/categories/中间件/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://tonywang1.github.io/tags/中间件/"}]},{"title":"tkmybatis集成","slug":"2020/java/tkmybatis-use","date":"2020-03-10T15:41:13.000Z","updated":"2020-03-10T09:20:23.720Z","comments":true,"path":"2020/03/10/java-tkmybatist/","link":"","permalink":"https://tonywang1.github.io/2020/03/10/java-tkmybatist/","excerpt":"","text":"cloud_test描述 spring，tk.mybatis 与PageHelper的集成 參考： https://github.com/godlike110/tk-mybatis https://github.com/abel533/MyBatis-Spring-Boot 集成步骤 1 添加maven mapper-spring-boot-starter pagehelper-spring-boot-starter 2 添加mybatis配置MybatisConfiguration 3 所有mapper继承Mapper 4 需要分页的地方调用PageHelper.startPage(currentPage, pageSize); 5 分页返回的列表需要强制转换为page：PageInfo(list); 6 实体和字段映射关系，需要在实体上添加注解 集成实例 集成实例","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"学习类库","slug":"2020/struct/learn-page","date":"2020-03-10T15:41:13.000Z","updated":"2020-08-06T12:42:44.222Z","comments":true,"path":"2020/03/10/java_lean/","link":"","permalink":"https://tonywang1.github.io/2020/03/10/java_lean/","excerpt":"","text":"JAVA值得关注的学习库 JavaGuideGithub地址： https://github.com/Snailclimb/JavaGuide CS-NotesGithub 地址：https://github.com/CyC2018/CS-Notes10 advanced-javaGithub地址：https://github.com/doocs/advanced-java JCSproutGithub地址：https://github.com/crossoverJie/JCSprout toBeTopJavaerGithub地址：https://github.com/hollischuang/toBeTopJavaer architect-awesomeGithub地址：https://github.com/xingshaocheng/architect-awesome technology-talkGithub地址： https://github.com/aalansehaiyang/technology-talk","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"架构整理","slug":"2020/struct/struct-use","date":"2020-03-10T15:41:13.000Z","updated":"2020-03-11T02:02:03.446Z","comments":true,"path":"2020/03/10/struct/","link":"","permalink":"https://tonywang1.github.io/2020/03/10/struct/","excerpt":"","text":"架构知识整理1、一些开源项目的记录 vm下载地址：http://www.downza.cn/soft/277470.html 淘宝开源项目汇总：https://www.javazhiyin.com/33790.html 阿里开源的jar：https://www.mvnjar.com/com.alibaba.middleware/list.html arthas项目：https://alibaba.github.io/arthas/arthas-tutorials?language=cn mybatis通用mapper：https://gitee.com/free/Mapper/wikis/Home sql解析器：https://github.com/JSQLParser/JSqlParser 2、项目与开源项目的契合点 监控：Prometheus,alertmanager, puppet+zabbix，或者saltstack+zabbix open-falcon全监控 日志：flink(实时分析，实时监控，ETL，告警 )、flume ，es存储 网关：Kong、 自动化运维：SaltStack 自动部署： jenkins 自建cdn：squid dns 机器硬件信息采集：puppet 自建dns ：powerdns（github上），smartdns(https://github.com/pymumu/smartdns/releases) 切图工具： 代码管理：svn、git(Webhooks机制做代码部署) 存储工具：ceph 、TFS、FastDFS 微服务：dubbo(https://github.com/dubbo)(https://github.com/apache/dubbo-spring-boot-project),spring cloud(https://www.springcloud.cc/)( https://github.com/spring-cloud ) ,SOFABootService Mesh：Envoy 代码质量：Sonar 自动伸缩部署：容器、Istio、 分布式追踪系统： SkyWalking 服务网格：Istio、Linkerd 测试：jmeter rpc：grpc 跨语言通信方案 Thrift、Protobuf、Avro 深度学习框架：TensorFlow、Keras等 服务器数据上报：puppet 反编译：http://java-decompiler.github.io/ 网页流量统计网站：http://www.matomo.net.cn/category/tutorial/ AB测试灰度发布-*团服务治理也是参考这个的：https://github.com/CNSRE/ABTestingGateway.git CAT ：应用系统实时监控以及告警 HTTP/2：可以对数据压缩增加传输速度 数据库中间件：DBProxy(美团)，Atlas（https://github.com/Qihoo360/Atlas），mycat（http://www.mycat.io/），Zebra（美团） 数据库sharding： Hibernate Shards 、 Ibatis-Sharding，TDDL（阿里） ID生成策略:数据库自增、uuid、snowflake、依赖mysql生成自增（美团点评leaf） 分布式任务调度：https://www.xuxueli.com/xxl-job/（调度、单点、缓存、服务注册） KMS统一密钥管理系统:参考https://github.com/ligson/kms/blob/master/README.md camus：kafka数据导入到hdfs的解决方案 服务通信框架、弹性负载均衡、服务治理代理（服务注册/发现、配置更新、访问控制、上报调用情况）、服务治理平台、命名服务、配置中心、健康检查、 限流：Guava的RateLimiter 断路器、线程池隔离：Hystrix 流量控制、熔断降级、系统负载保护：Sentinel (https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D) 服务注册和发现：ZooKeeper、Eureka、Consul 、Nacos 共享元数据、数据分级、审计、安全性以及数据保护：Atlas权限控制：Apache Ranger KV存储tair-redis集群（Codis）：https://github.com/alibaba/tair/wiki/%E4%B8%AD%E6%96%87%E4%B8%BB%E9%A1%B5 Codis：https://github.com/CodisLabs/codis 全链路线上压测的目的主要有：参考：① 了解整个系统的处理能力② 排查性能瓶颈③ 验证限流、降级、熔断、报警等机制是否符合预期并分析数据反过来调整这些阈值等信息④ 发布的版本在业务高峰的时候是否符合预期⑤ 验证系统的依赖是否符合预期 美团可用性实践：https://tech.meituan.com/2018/04/19/trade-high-availability-in-action.html 美团点评中间件技术介绍：https://awps-assets.meituan.net/mit-x/slide-bundle-2018/34/1-%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF.pdf 服务间调用解耦参考：https://tech.meituan.com/2018/07/26/sep-service-arrange.html 美团规则引擎设计：https://tech.meituan.com/2017/06/09/maze-framework.html 开源规则引擎drools：https://www.drools.org/ 字节码增强：https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html 美团移动网络优化：https://tech.meituan.com/2017/03/17/shark-sdk.html 美团定制化路由：https://tech.meituan.com/2018/09/06/oceanus-custom-traffic-routing.html 美团权限系统：https://tech.meituan.com/2019/02/14/data-security-platform-construction-practice-jiangjunling.html 美团日志收集：https://tech.meituan.com/2020/01/09/meituan-logan.html mysql的binlog同步机制：https://github.com/alibaba/canal mysql数据同步参考：https://github.com/hjx601496320/plumber 数据库变更抓取：https://github.com/linkedin/databus/blob/master/README.md1）主数据库和衍生数据库的同步2）将数据库数据同步到缓存中 ESB代表项目：JBOSS ESB,Mule,Camel 以及一些其他的esb项目 ESB和服务注册之间的区别：1、两类开源项目侧重点不同，ESB侧重任务的编排，性能问题可通过异构的方式来进行规避。无法支持特别大的并发2、服务注册侧重服务的治理，将各个服务颗粒化，各个子业务系统在程序逻辑上完成业务的编排。但是比较实用较大的并发量，因为dubbo类的只是存放服务地址。 有zookeeper类的分布式通讯框架，能保证单点的失败不影响整个系统的业务调用，因为业务接口都是在各个提供服务的子系统中。 3、360开源项目 1）类Redis存储系统 Pika，https://github.com/Qihoo360/pika 2）日志搜索平台 Poseidon 3）高性能分布式存储服务 HustStore 4）抓包工具 MySQL Sniffer 5）代码质量检测工具 GoReporter，https://github.com/wgliang/goreporter 6）配置管理工具QConf，https://github.com/Qihoo360/QConf/blob/master/README_ZH.md 4、阿里巴巴开源项目 1 分布式应用服务开发的一站式解决方案 Spring Cloud Alibaba地址：https://github.com/spring-cloud-incubator/spring-cloud-alibaba 2 JDBC 连接池、监控组件 Druid地址：https://github.com/alibaba/druid 3 服务框架 Dubbo地址：https://github.com/alibaba/dubbo 4 企业级流式计算引擎 JStorm地址：https://github.com/alibaba/jstorm 5 分布式数据层 TDDL地址：https://github.com/alibaba/tb_tddl 6 Java 图片处理类库 SimpleImage地址：https://github.com/alibaba/simpleimage 7 开源 Java 诊断工具 Arthas 8.动态服务发现、配置和服务管理平台 Nacos地址：https://nacos.io/en-us/ 9.Java 解析 Excel 工具 easyexcel地址：https://github.com/alibaba/easyexcel 10.高可用流量管理框架 Sentinel地址：https://github.com/alibaba/Sentinel 11.基于多维度 Metrics 的系统度量和监控中间件 SOFALookout地址：https://github.com/alipay/sofa-lookout 12.基于 Spring Boot 的研发框架 SOFABoot地址：https://github.com/alipay/sofa-boot 13 轻量级分布式数据访问层 CobarClient地址：https://github.com/alibaba/cobarclient 5、关键词介绍 CQRS：CQRS（Command Query Responsibility Segration）架构，大家应该不会陌生了。简单的说，就是一个系统，从架构上把它拆分为两部分：命令处理（写请求）+查询处理（读请求）。然后读写两边可以用不同的架构实现，以实现CQ两端（即Command Side，简称C端；Query Side，简称Q端）的分别优化。CQRS作为一个读写分离思想的架构，在数据存储方面，没有做过多的约束 MDM：Master Data Management，翻译为主数据管理或元数据管理高性能规则：避开网络开销（IO），避开海量数据，避开资源争夺 6、问题整理 1 解决APP中DNS劫持和公网DNS依赖导致的问题自己维护域名和ip对应关系表，通过检测找出速度最快的，然后通过ip进行接口访问 2 APP通过长连接提升访问速度APP通过TCP访问中间代理长连服务器（IP直连，减少公网DNS依赖），然后代理服务器通过http短链接访问我们自己的服务器（1 建设专线提高访问速度，2自建DNS减小公网DNS的依赖）， 3 HTTP流量定制化路由，可以参考AB测试灰度发布,nginx添加lua，根据不同规则进行路由HTTP负载均衡-LB-美团的Oceanus（可以进行拆分为：4层LB、7层LB）","categories":[{"name":"架构","slug":"架构","permalink":"https://tonywang1.github.io/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://tonywang1.github.io/tags/架构/"}]},{"title":"GIT使用","slug":"2020/git/git使用","date":"2020-02-28T15:41:13.000Z","updated":"2020-02-29T10:01:29.668Z","comments":true,"path":"2020/02/28/git-know-use/","link":"","permalink":"https://tonywang1.github.io/2020/02/28/git-know-use/","excerpt":"","text":"GIT使用 1.什么是GIT 免费开源的分布式版本控制系统，小或者大的工程使适应 2.GIT作用和优点 GIT有工作区间、本地仓库、远程仓库，在没有网络的情况下依然可以用本地仓库进行版本控制。 3.GIT中涉及到的关键字与关键词 HEADER 当前活跃的分支 origin 默认远程仓库的名称 4.git工作流程： git有三个工作树，即工作目录 1）本地工作目录，它持有实际文件2）暂存区域，像一个缓存区域，保存你的改动3）HEAD区域，指向你最后一次提交的结果。 每次提交的时候，add文件，则文件提交到暂存区域即第二个区域，然后commit文件，则文件会被提交到HEAD区域，这个时候其他人还看不到文件的改动，最后需要push，将文件推送到远端的服务器上 5.GIT中常用的命令以及使用场景 创建新仓库：创建新文件夹，打开，然后执行 git init 检出仓库： 本地：git clone /path/to/repository 远端：git clone username@host:/path/to/repository 提交文件$ git status -sgit add git commit -m “代码提交信息”git pull #（将服务器项目与本地项目合并）git push origin master 可以把 master 换成你想要推送的任何分支 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：git remote add origin （git remote add origin master或 git remote add origin git@github.com:YotrolZ/helloTest.git ）删除本地和远程的关联关系： git remote remove origin 要更新你的本地仓库至最新改动，执行：git pull 在合并改动之前，你可以使用如下命令预览差异git diff 获取（fetch） 并 合并（merge） 远端的改动。 要合并其他分支到你的当前分支（例如 master）git merge 并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：git add 假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。git checkout – 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：git fetch origin（当某个分支看不到的时候，可以这样进行索引更新） - 更新远程分支最新信息到本地，会将远程新创建的分支信息写到 FETCH_HEAD(所有的分支信息)文件中git reset –hard origin/master1111 查看远程有什么数据仓库git remote -v git版本回退查看所有版本号git reflog 根据版本号恢复到某个版本git reset –hard 6fcfc89 $ git push origin :master等同于$ git push origin –delete master 直接提交：git push origin source -f 6.git的分支管理 git分支操作在本地建立分支，然后与本地主枝合并，最终提交到服务器。有效的避免了因个人操作不当向服务器提交过多脏数据，避免频繁git clone服务器来更新本地库。 分支操作指令： 建立分支git branch AAA #建立分支AAA 分支切换git checkout AAA #从当前分支切换到AAA分支 将分支与主枝master合并git checkout master #（首先切换回主枝）git merge AAA #（将分支AAA与主枝合并） 当前分支查看git branch #默认有master（也称为主枝）git branch –a 查看当前所有分支 删除分支git branch –d AAA #删除分支AAA 删除所有 有远程分支的本地分支git remote prune origin 7..gitignore使用，根目录创建文件.gitignore 忽略根目录文件：/.project 忽略根目录下的目录：/target/ 注意：忽略的目录和文件必须是git没有追踪的（untraced）,如果文件或者目录是已经设置了跟踪，则需要先删除版本库跟踪，然后提交（git commit -m “评”），这时候文件夹或者文件的忽略跟踪才会生效 git 删除被管理的文件 git rm —cached filePath git 删除被管理的文件夹 git rm -r -f —cached filePath git 不再追踪文件改动 git update-index --assume-unchanged filePath git 恢复追踪文件改动 git update-index —no-assume-unchanged filePath 原则：文件未追踪的情况下，添加到.gitignore中，达到忽略文件提交的目的 如果文件已经提交或者已经添加追踪，则删除提交或者删除追踪即可 7.elipse中使用git 1 Add to Index ，添加文件到git追踪下 2 Remove from Index ，文件去掉git追踪 3 team-&gt;commit 提交文件到本地仓库 4 team-&gt;Repository-&gt;Push to upstream或者push Branch Master 提交到远程共享仓库 5 replace -&gt; head Revision 本地仓库最新文件 6 replace -&gt; Prevision Revision 新版本 7 文件冲突 pull 将新文件下载下来，手动解决冲突， add 然后push新文件到线上 7.SOURCETREE修改用户名和密码删除C:\\Users%USERNAME%\\AppData\\Local\\Atlassian\\SourceTree 目录下的passwd文件， 能移除掉保存的密码。删除C:\\Users%USERNAME%\\AppData\\Local\\Atlassian\\SourceTree 目录下的userhosts文件， 能移除掉保存的用户名 8.可能会遇到的问题 如果账号密码有变动，需要修改的话：1 删除：AppData\\Local\\Atlassian\\SourceTree\\passwd2 git config –system –unset credential.helper 不行的话git config –global http.emptyAuth true git异常ssl权限问题：git config –global http.sslVerify false 7.主要参考 安装包下载","categories":[{"name":"GIT","slug":"GIT","permalink":"https://tonywang1.github.io/categories/GIT/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"https://tonywang1.github.io/tags/GIT/"}]},{"title":"字节码增强","slug":"2020/java/bytecode-enhancement","date":"2020-01-20T15:41:13.000Z","updated":"2020-01-20T03:08:28.974Z","comments":true,"path":"2020/01/20/java-bytecode-enhancement/","link":"","permalink":"https://tonywang1.github.io/2020/01/20/java-bytecode-enhancement/","excerpt":"","text":"JAVA字节码增强 1.什么是字节码 java源代码编译以后的class文件为字节码 2.如何对字节码进行修改 asm、javassist等类库进行修改 3.字节码修改以后如何动态替换运行时JVM中对应的信息pid-&gt; javaagaent(agent加载到运行时jvm上) -&gt; Instrumentation(Transformer替换那个class文件)-&gt; ClassFileTransformer(字节码对方法进行修改) -&gt; 4.字节码增强运用场景 热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。 性能诊断工具：比如bTrace就是利用Instrument，实现无侵入地跟踪一个正在运行的JVM，监控到类和方法级别的状态信息。 AOP 5.idea插件jclasslib 查看字节码工具 6.主要参考 美团字节码增强总结文章","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"Lua语言基础","slug":"2019/11/26/lua_basic","date":"2019-11-26T15:41:13.000Z","updated":"2019-11-26T08:12:36.531Z","comments":true,"path":"2019/11/26/lua_basic/","link":"","permalink":"https://tonywang1.github.io/2019/11/26/lua_basic/","excerpt":"","text":"#LUA语言简介 1.什么是Lua语言 Lua是一种强大，高效，轻量级，可嵌入的脚本语言 2.特性它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里 3.LUA能解决什么问题Nginx + lua 处理http请求时，可在11个阶段插入lua脚本redis + lua 实现原子操作，避免多线程数据不一致的问题 3.LUA环境搭建搭建参照 4.基础语法记录-主要记录学习中独特的地方1) 基础语法学习参照2)逻辑运算符短路求值 12and 逻辑与操作符。 “短路求值” 若 A 为 false，则返回 A，否则返回 B。 (A and B) 为 false。or 逻辑或操作符。“短路求值” 若 A 为 true，则返回 A，否则返回 B。 (A or B) 为 true。 3)bool类型lua中除了false和nil之外，其他所有数据，包括0、空字符串等都是true。4) 类型判断 1234567print(type(&quot;Hello world&quot;)) --&gt; stringprint(type(10.4*3)) --&gt; numberprint(type(print)) --&gt; functionprint(type(type)) --&gt; functionprint(type(true)) --&gt; booleanprint(type(nil)) --&gt; nilprint(type(type(X))) --&gt; string 5)nil删除功能对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉6)nil 作比较时应该加上双引号 123457)字符串和数字运算一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字8)字符串连接``` print(&quot;a&quot; .. &apos;b&apos;) tonumber(字符串) -- tostring(bVar) 9)字符串长度使用 # 来计算字符串的长度，放在字符串前面 10)table类型-数组、哈希、包、类- 都可以通过table实现 1、不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始 2、”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。 3、table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil 4、对 table 的索引使用方括号 []。Lua 也提供了 . 操作 Lua table 是不固定大小的，你可以根据自己需要进行扩容Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用”format”来索引table string 11)table类型是否为nil变量 1234567function isTableEmpty(t) if t == nil or _G.next(t) == nil then return true else return false endend 12)全局变量和局部变量a = 5 – 全局变量local b = 5 – 局部变量 13)Lua 可以对多个变量同时赋值Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量 14)循环 12345678910111213while( true )do print(\"循环将永远执行下去\")endif(0)then print(\"0 为 true\")endfor k, v in pairs(tab1) do print(k .. \" - \" .. v)end 15)函数 Lua函数可以返回多个结果值，比如string.find，其返回匹配串”开始和结束的下标”（如果不存在匹配串返回nil）。 Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 … 表示函数有可变的参数 我们也可以通过 select(“#”,…) 来获取可变参数的数量 有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前 通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select(‘#’, …) 或者 select(n, …)select(‘#’, …) 返回可变参数的长度select(n, …) 用于访问 n 到 select(‘#’,…) 的参数 5.Lua在nginx中的使用一、阶段执行流程二、Nginx API for Lua 三、常用阶段 content_by_lua 是内容处理器，接受请求并输出响应，适用于location、location if。 access_by_lua 在请求访问阶段处理，用于访问控制，适用于http、server、location、location if。 rewrite_by_lua 测试只有在重定向的时候才会调用 set_by_lua set_by_lua_file执行Nginx外部的lua脚本，可以避免在配置文件中使用大量的转义 四、使用实例1 123456789101112131415161718location / &#123; rewrite_by_lua &apos; local res = ngx.location.capture(&quot;/check-spam&quot;) if res.body == &quot;spam&quot; then ngx.redirect(&quot;/terms-of-use.html&quot;) end &apos;; fastcgi_pass ...;&#125;location /echo &#123; default_type text/plain; echo hello lua;&#125;location /lua &#123; default_type text/plain; content_by_lua &apos;ngx.say(&quot;hello world&quot;)&apos;;&#125; 五、使用实例2-ip禁止功能 123456789101112131415location @client&#123; proxy_pass http://www.baidu.com;&#125;location ~ /test &#123; default_type text/html; content_by_lua &apos;ngx.say(&quot;this is ruifengyun.com!&quot;)&apos;; access_by_lua &apos; if ngx.var.remote_addr == &quot;101.2.20.110&quot; then ngx.exit(ngx.HTTP_FORBIDDEN) end if ngx.var.remote_addr == &quot;101.21.20.112&quot; then ngx.exec(&quot;@client&quot;) end &apos;;&#125; 六、重定向转发-获取重定向的参数 12345678910111213141516171819location /foo &#123; content_by_lua_block &#123; ngx.exec(&quot;/bar&quot;, &quot;a=goodbye&quot;); &#125;&#125;location /bar &#123; default_type text/plain; content_by_lua_block &#123; local args = ngx.req.get_uri_args() for key, val in pairs(args) do if key == &quot;a&quot; then ngx.say(val) end end &#125;&#125; 七、nginx定义的变量 lua中可以获取 123456789location /foo &#123; set $my_var &apos;&apos;; # this line is required to create $my_var at config time ngx.arg[1]可以获取定义的参数 content_by_lua_block &#123; ngx.var.my_var = 123; ... &#125;&#125;删除变量方法：ngx.var.args = nil如：ngx.var.name = nil 删除nginx中name的变量 八、ngx.ctx-一个生命周期中共享变量 1234567891011location /test &#123; rewrite_by_lua_block &#123; ngx.ctx.foo = 76 &#125; access_by_lua_block &#123; ngx.ctx.foo = ngx.ctx.foo + 3 &#125; content_by_lua_block &#123; ngx.say(ngx.ctx.foo) &#125;&#125; 九 几个常用的api地址 [方法常量](https://github.com/openresty/lua-nginx-module* #http-method-constants) 状态常量 日志级别常量 nginx头处理 重定向 十、常用API记载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 ngx.req.set_uri ngx.req.set_uri(&quot;/foo&quot;, true)ngx.req.get_uri_argsngx.req.set_uri_argslocal args, err = ngx.req.get_post_args()ngx.req.get_headersngx.req.set_headerngx.req.clear_headerngx.req.read_bodyngx.req.get_body_filengx.req.set_body_datangx.redirectngx.print 没有回车 ngx.say 有回车 ngx.flushngx.exit(501) 返回状态吗，并直接退出 ngx.sleepngx.todayngx.timengx.nowngx.update_timengx.utctimengx.re.matchngx.re.findngx.re.gmatchngx.re.subngx.re.gsubngx.shared.DICTlocal ok, err = ngx.timer.at(2, mylog ) 延时器，只会执行一次 --写响应头 ngx.header.a = &quot;1&quot; --多个响应头可以使用table ngx.header.b = &#123;&quot;2&quot;, &quot;3&quot;&#125; --输出响应 ngx.say(&quot;a&quot;, &quot;b&quot;, &quot;&lt;br/&gt;&quot;) ngx.print(&quot;c&quot;, &quot;d&quot;, &quot;&lt;br/&gt;&quot;) --200状态码退出 return ngx.exit(200) 必须调用exit给出状态码ngx.say(&quot;api is offline!&quot;)ngx.exit(200)获取消息体，先打开获取消息体的开关：ngx.req.read_body()local data = ngx.req.get_body_data()local request_uri = ngx.var.request_uri or &quot;&quot;resty.iputils 工具类使用：https://github.com/hamishforbes/lua-resty-iputils 6.主要参考 1) Lua官网 2) luajit官网 3）openresty 4）lua-nginx-module","categories":[{"name":"Lua","slug":"Lua","permalink":"https://tonywang1.github.io/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://tonywang1.github.io/tags/Lua/"}]},{"title":"MYSQL使用基础记录","slug":"2019/09/27/MYSQL使用基础记录","date":"2019-11-21T19:31:12.000Z","updated":"2019-11-21T12:04:40.083Z","comments":true,"path":"2019/11/22/mysql_basic/","link":"","permalink":"https://tonywang1.github.io/2019/11/22/mysql_basic/","excerpt":"","text":"#MYSQL使用基础记录 1.变量的定义 第一种用法：set @num=1; 或set @num:=1; //这里要使用变量来保存数据，直接使用@num变量 第二种用法：select @num:=1; 或 select @num:=字段名 from 表名 where …… 123实例如：1）set @t_error=0; select @t_error ;2）select @num:=`name` from sys_area where id=2 ; select @num; 2.启动事务和提交事务,回滚事务，如果打算启动事务则，设置自动提交为0，start transaction ; commit; 123456789 # 数值1自动提交 0手动提交select @@autocommit; #设置手动提交set @@autocommit=0;start transaction ; insert into dic(name ) values('1'); insert into dic(name ) values('2'); ROLLBACK;commit; 3.数据库的四个特性特性：原子性，一致性，隔离性，持久性.其中隔离性是不同事务之间的隔离原则，需要设置事务隔离级别来处理。 4.事务的隔离级别 1、 Read Uncommitted（读取未提交内容-未提交读） 2、 Read Committed（读取提交内容-提交读） 3、Repeatable Read（可重读） 4、 Serializable（可串行化） 123456781）查看当前会话隔离级别select @@tx_isolation;2）查看系统当前隔离级别select @@global.tx_isolation;3）设置当前会话隔离级别set session transaction isolatin level repeatable read;4）设置系统当前隔离级别set global transaction isolation level repeatable read; 5.数据库的共享锁和排它锁查询当前有多少事务，多少锁 12SELECT * FROM information_schema.INNODB_TRX ;SELECT * FROM information_schema.INNODB_LOCKS; 共享锁和排它锁不同点在于是否允许另一个事务读取被锁住的数据 共享锁锁住了一条id=1的数据，则其他的事务是可以读取，但不能更改 排它锁锁住了一条id=1的数据，其他的事务不可以读取，也不能更改，直到这个事务完成 如果另一个查询没有显示添加锁，则他是可以读取数据，不受上面锁影响 举个栗子： 1234567891011select @@autocommit; #设置手动提交set @@autocommit=0;set @t_error=0;select @t_error ;start transaction ; select * from dic for update ; insert into dic(name ) values('1'); insert into dic(name ) values('2'); ROLLBACK;commit; 6.外键删除外键不能直接删除，必须先删除外键然后删除相应的索引 1234567#查看表的外键以及外键名称show create table 表名#删除外键alter table 表名 drop FOREIGN KEY 外键名称 ;#显示所有的索引，并且删除需要删除的索引show index from 表名称 ;alter table 表名称 drop index FK_cv98jak9 ; 7.字段删除和添加12alter table 表名 drop column cluster_numalter table 表名 add cluster_num int comment &apos;数量&apos;; 8.NULL问题SELECT 1 = NULL, 1 &lt;&gt; NULL, 1 &lt; NULL, 1 &gt; NULL;9. 显示执行的进程show full processlist （状态字段的意思）或者（select * from information_schema.processlist where host like ‘%10.18.2.65%’） Sleep通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内（一般连接池会有一个参数initialSize，如果initialSize=10则初始化的时候会有10个状态为sleep连接被建立，并且一直存在），例如：数据查询时间为0.1秒，而网络输出需要1秒左右，原本数据连接在0.1秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在结果未展现在用户桌面前，该数据库连接一直维持在sleep状态 Locked操作被锁定，通常使用innodb可以很好的减少locked状态的产生 Copy to tmp table索引及现有结构无法涵盖查询条件时，会建立一个临时表来满足查询要求，产生巨大的i/o压力Copy to tmp table通常与连表查询有关，建议减少关联查询或者深入优化查询语句，如果出现此状态的语句执行时间过长，会严重影响其他操作，此时可以kill掉该操作 Sending dataSending data并不是发送数据，是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，如果sending data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化 Storing result to query cache如果频繁出现此状态，使用set profiling、“SHOW PROFILE” 分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query cache碎片较多，使用flush query cache可即时清理，Query cache参数可适当酌情设置 1 开启profiling功能：set profiling=1;2 显示所有记录的profile：show profiles;3 详细输出某个profile的记录：show profile cpu ,block io for query n(profile的id) 10.mysql日期时间函数的处理123456789101112131415date_format(date, format) 函数，MySQL日期格式化函数date_format()unix_timestamp( 时间日期) 函数 ，Mysql日期转换为unix时间戳str_to_date(str, format) 函数 ，字符串转化日期from_unixtime(unix_timestamp, format) 函数，MySQL时间戳格式化函数from_unixtime实例select DATE_FORMAT(now(),'%Y-%m-%d' ) select str_to_date('2017-12-08 00:00:00', '%Y-%m-%d %H:%i:%s' ) select unix_timestamp( DATE_FORMAT(now(),'%Y-%m-%d' ) )*1000 ;select unix_timestamp( str_to_date('2017-12-08 00:00:00', '%Y-%m-%d %H:%i:%s' ) )*1000 ;select from_unixtime( unix_timestamp( DATE_FORMAT(now(),'%Y-%m-%d' ) ),'%Y-%m-%d %H:%i:%s' ) ;数据库中的时间错：FROM_UNIXTIME(left(a.created_at,10), '%Y-%m-%d %H:%i:%S')&gt;'2018-01-01 00:00:00' select step_name,FROM_UNIXTIME(left(a.start_time,10), '%Y-%m-%d %H:%i:%S') 开始时间,FROM_UNIXTIME(left(a.end_time,10), '%Y-%m-%d %H:%i:%S') 结束时间from task_step1 a 11.多表关联更新与删除 关联更新一个表的数据123update user a join user_ext b on a.uid=b.id set b.name=a.name, b.age=a.agewhere ifNULL(a.business_ip,&apos;&apos;)&lt;&gt;ifNULL(b.new_business_ip,&apos;&apos;) 关联删除h表的数据123delete h.* from user g join user_ext h on g.id=h.userIdwhere g.id=1 12.in和exist的区别参照 13.数据导出和导入 备份：mysqldump 数据库名称 -u’用户名’ -p &gt; 表名称.sqlmysqldump -u 用户名 -p ‘密码’ –host=远程服务器地址 数据库名称 &gt; 数据库名称1.sql /usr/local/mysql/bin/mysqldump -q -h127.0.0.1 -udmin -p’密码’ -P3306 –single-transaction –databases 数据库名称 &gt; /data/tmp/备份数据库名_20111019.sql 导入：mysql&gt; source /tmp/表名称.sql 登陆：mysql -h mysql远程地址 -u 用户名 -p’密码’ 14.数据库的common内容显示乱码：修改编码格式123show variables like &apos;char%&apos;set character_set_connection=utf8 ;set character_set_results=utf8;","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://tonywang1.github.io/categories/MYSQL/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://tonywang1.github.io/tags/MYSQL/"},{"name":"SQL","slug":"SQL","permalink":"https://tonywang1.github.io/tags/SQL/"}]},{"title":"GO语言基础","slug":"2019/10/29/go-basic","date":"2019-10-12T15:41:13.000Z","updated":"2019-11-18T12:41:51.748Z","comments":true,"path":"2019/10/12/go_basic/","link":"","permalink":"https://tonywang1.github.io/2019/10/12/go_basic/","excerpt":"","text":"#GO语言简介个人从学习从入手不到一周基本可以开始开发：1 go语法基础看了一遍2 经常用到的难点突破一下3 beego网路开发官方文档主要的部分看一遍 1.什么是GO语言Go（又称 Golang）是 Google 开源的一种静态强类型、编译型语言 2.什么要用GO语言 简单高效 开发速度快 容易开发并行性代码 部署简单 3.GO如何安装 下载go-https://golang.org/dl/ 安装并设置go的环境变量-go的bin目录添加的环境变量path中 ，C:\\Go\\bin 执行go version ，打印go的版本，安装完成 go evn，打印go的所有相关变量 4.基础语法记录基础语法学习参考 1) 指针、对象、值传递和引用传递 go普通变量:变量直接指向存在内存中的值 go指针变量**:变量指向值存储的地址，实际的内存地址 new(T) 返回 T 的指针 *T， 并指向 T 的零值。– 指针 make(T) 返回的初始化的 T的引用，只能用于 slice，map，channel。 - 引用 City{Id: id} == 返回对象引用 new(City) == 返回对象指针 函数的参数两种：值传递（数值的拷贝）、引用传递（指针） 2) 类型转换 strconv - 字符串和各种数据类型的转换 整数之间转换 整数之间强转：int := int(int32) 整数转为字符串：strconv.Itoa( ) boolean转为字符串：strconv.FormatBool(isDebug) 字节与字符串的转换： var a = []byte(“hello boy”) var b = string(a) strings:字符串的工具类 3) 命名规范 golang的命名推荐使用驼峰命名法，必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线 golang中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用可以简单的理解成，首字母大写是公有的，首字母小写是私有的 结构体中属性名的大写-小写的json不能解析 4) json使用 类型断言:interface.(int) 反序列化，指定对应的struct，只有key的第一个字母大写才能被反序列化 序列化key必须是字符串，值为指针，则序列化为对应的值 5) simplejson使用 simplejson：解析复杂json，解析时候最好从根部解析。 参照：https://blog.csdn.net/chenghuan1990/article/details/75423325 6) struct tags修改json序列化和反序列化的对应 改变对应序列化和反序列化后的名称 指定空值得处理 是否忽略某个字段 类型判断：switch vv := v.(type) 7)io.Reader/Writer常用 字节缓冲区，字节、字符串、Reader之间的操作 net.Conn, os.Stdin, os.File: 网络、标准输入输出、文件的流读取 strings.Reader: 把字符串抽象成Reader bytes.Reader: 把[]byte抽象成Reader bytes.Buffer: 把[]byte抽象成Reader和Writer bufio.Reader/Writer: 抽象成带缓冲的流读取（比如按行读写） 8) http使用 restclient: https://github.com/ylywyn/restclient 标准库：http 5.IDEA中开发GO项目 1 设置GOROOT-项目相关的包都是从这个目录开始查找的 2 设置GOPATH-添加gopath到设置中 3 Setting的设置GoModule ，允许go module集成 ，设置Proxy=https://goproxy.cn 4 生成依赖管理文件go.mod: go mod init – 项目使用modules管理，并生成管理文件go.mod每次build会将项目中的包信息，放到这个文件中go mod download – 会将项目依赖包放到go安装目录的pkg目录中，所有项目共享go.mod文件：为项目的依赖包，描述项目的名称和依赖的第三方的包go.sum文件：为项目的依赖分析文件，记录每个依赖库的版本和哈希值 5 将依赖包生成到本地: go mod vendor - 将依赖包放到项目中的vendor目录中，本项目独有，idea就可以识别了 6 启动项目 ： bee run -gendoc=true -downdoc=true 注意： 1 项目要用go的module形式进行管理 go mod init 2 项目中引入的所有包进入到包管理文件： go build（会将包信息写到go.mod中） 3 下载对应的包到项目的vendor目录中：go mod vendor 6.主要参考 1) https://www.runoob.com/go/go-tutorial.html 2) beego官网 3）go官网","categories":[{"name":"GO","slug":"GO","permalink":"https://tonywang1.github.io/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"https://tonywang1.github.io/tags/GO/"}]},{"title":"protobuf使用","slug":"2019/10/12/protobuf使用","date":"2019-10-12T15:41:13.000Z","updated":"2019-10-12T07:46:28.969Z","comments":true,"path":"2019/10/12/you_know_pb/","link":"","permalink":"https://tonywang1.github.io/2019/10/12/you_know_pb/","excerpt":"","text":"Protocol Buffer初识 1.什么是protobufgoogle开发的跨语言、跨平台、可扩展的可以序列化的数据结构，像XML一样，但是更小更快，更简单，你可以定义序列化的数据结构，然后用工具生成对应语言的源码，最后可以用各种语言对数据流结构进行读写。 2.protobuf优势在哪里 跨语言 跨平台 可扩展 小、快、简单 3.什么地方使用protobuf 数据压缩传输 数据压缩存储、持久化 4.在java中如何使用protobuf-maven插件可以直接生成java代码 创建proto目录，并在里面创建bookdress.proto文件-内容如代码4.1 maven的xml中添加protobuf文件生成源码的代码-内容如4.2 测试写入protobuf的代码4.3 测试读取protobuf的代码4.41234567891011121314151617181920212223代码4.1syntax = \"proto2\";package proto;option java_package = \"com.test.proto\";option java_outer_classname = \"AddressBookProtos\";message Person &#123; optional string name = 1; optional int32 id = 2; optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; optional string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phones = 4;&#125;message AddressBook &#123; repeated Person people = 1;&#125; 1234567891011121314151617181920212223242526272829303132333435363738代码4.2 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt; &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1.Final&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;protocArtifact&gt;com.google.protobuf:protoc:3.4.0:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 12345678910111213141516171819202122232425262728293031323334353637代码4.3package com.test;import com.test.proto.AddressBookProtos;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class WritePerson &#123; public static final String addr_book = \"addr_book.file\"; // 写入文件的名称 static AddressBookProtos.Person PromptForAddress(int index) throws IOException &#123; AddressBookProtos.Person.Builder person = AddressBookProtos.Person.newBuilder(); person.setId(index); person.setName(\"proto test \" + index); person.setEmail(\"a\"+index+\"@b.com\"); AddressBookProtos.Person.PhoneNumber.Builder phoneNumber = AddressBookProtos.Person.PhoneNumber.newBuilder().setNumber(\"110-\"+index); phoneNumber.setType(AddressBookProtos.Person.PhoneType.HOME); person.addPhones(phoneNumber); return person.build(); &#125; public static void main(String[] args) throws Exception &#123; AddressBookProtos.AddressBook.Builder addressBook = AddressBookProtos.AddressBook.newBuilder(); try &#123; addressBook.mergeFrom(new FileInputStream(addr_book)); &#125; catch (FileNotFoundException e) &#123; System.err.println( \" File not found. Creating a new file.\"); &#125; // 创建 address. addressBook.addPeople(PromptForAddress(1)); addressBook.addPeople(PromptForAddress(2)); addressBook.addPeople(PromptForAddress(3)); // 保存到文件 FileOutputStream output = new FileOutputStream(WritePerson.addr_book); addressBook.build().writeTo(output); output.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233代码4.4package com.test;import com.test.proto.AddressBookProtos;import java.io.FileInputStream;public class ReadPeople &#123; static void Print(AddressBookProtos.AddressBook addressBook) &#123; for (AddressBookProtos.Person person : addressBook.getPeopleList()) &#123; System.out.println(\"Person ID: \" + person.getId()); System.out.println(\" Name: \" + person.getName()); if (person.hasEmail()) &#123; System.out.println(\" E-mail address: \" + person.getEmail()); &#125; for (AddressBookProtos.Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123; switch (phoneNumber.getType()) &#123; case MOBILE: System.out.print(\" Mobile phone #: \"); break; case HOME: System.out.print(\" Home phone #: \"); break; case WORK: System.out.print(\" Work phone #: \"); break; &#125; System.out.println(phoneNumber.getNumber()); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; AddressBookProtos.AddressBook addressBook = AddressBookProtos.AddressBook.parseFrom(new FileInputStream(WritePerson.addr_book)); Print(addressBook); &#125;&#125; 5.主要参考 ProtoBuf的官方 ProtoBuf的maven集成插件 google开发者文档","categories":[{"name":"GRPC","slug":"GRPC","permalink":"https://tonywang1.github.io/categories/GRPC/"}],"tags":[{"name":"GRPC","slug":"GRPC","permalink":"https://tonywang1.github.io/tags/GRPC/"}]},{"title":"GO并发处理","slug":"2019/10/29/go-goroutine","date":"2019-10-12T15:41:13.000Z","updated":"2019-11-22T06:20:43.951Z","comments":true,"path":"2019/10/12/go_routine/","link":"","permalink":"https://tonywang1.github.io/2019/10/12/go_routine/","excerpt":"","text":"#GO并发处理 1.协程2.channal 概念：一个channel可以理解为一个先进先出的消息队列，有长度和容量，类似一个数组 作用：channel用来在协程[goroutine]之前传递数据，准确的说，是用来传递数据的所有权 设计：一个设计良好的程序应该确保同一时刻channel里面的数据只会被同一个协程拥有，这样就可以避免并发带来的数据不安全问题 类型： chan T是双向channel类型，编译器允许对双向channel同时进行发送和接收。 chan&lt;- T是只写channel类型，编译器只允许往channel里面发送数据。 &lt;-chan T是只读channel类型，编辑器只允许从channel里面接收数据。 定义：每一种channel类型都对应着一种简单的数据类型，进入这个channel的数据必须是这个数据类型用法： For-Range：for-range语法可以用到通道上。循环会一直接收channel里面的数据，直到channel关闭 channel阻塞：接收方会一直阻塞直到有数据到来。如果channel是无缓冲的，发送方会一直阻塞直到接收方将数据取出。如果channel带有缓冲区，发送方会一直阻塞直到数据被拷贝到缓冲区；如果缓冲区已满，则发送方只能在接收方取走数据后才能从阻塞状态恢复 3.select 关键字参考 1) 执行原理： 如果有一个或多个IO操作可以完成，则Go运行时系统会随机的选择一个执行， 否则的话，如果有default分支，则执行default分支语句， 如果连default都没有，则select语句会一直阻塞，直到至少有一个IO操作可以进行 2) select基本用法1234567select &#123;case &lt;- chan1:// 如果chan1成功读到数据，则进行该case处理语句case chan2 &lt;- 1:// 如果成功向chan2写入数据，则进行该case处理语句default:// 如果上面都没有成功，则进入default处理流程 3)作用select就是用来监听和channel有关的IO操作，当 IO 操作发生时，触发相应的动作 4) select中的break可以中途终止case中的操作 5)阻塞流程-无default如果没有default时，而且所有的case中的channal都没有接收到成功操作，则协程阻塞，这个可以控制协程处理流程 4.定时器NewTimer、NewTicker NewTimer 设定一个时间间隔，到设定时间则会将当前时间传到channal中 NewTicker 设定一个时间间隔，每隔设定时间间隔则将当前时间传到channal中 使用：定时器中如果时间到达与设定时间，则对应的channal会返回当时的时间，如果需要执行自定义函数需要，利用channal阻塞等待数据返回的特性实现定时器功能，执行自定义功能 1234567891011121314func TestTimer()&#123; //初始化定时器 t := time.NewTimer(5 * time.Second) //当前时间 now := time.Now() fmt.Printf(\"Now time : %v.\\n\", now) for &#123; //使用 channel阻塞特性，实现定时器 定时返回值 的功能 expire := &lt;- t.C fmt.Printf(\"Expiration time: %v.\\n\", expire) //重置定时间时间，重新计数 t.Reset( 3*time.Second ) &#125;&#125; 12345678910111213141516171819func TestTicker()&#123; //初始化定时器 t := time.NewTicker(1 * time.Second) //当前时间 now := time.Now() fmt.Printf(&quot;Now time is : %v.\\n&quot;, now) i:=0 for &#123; //使用 channel阻塞特性，实现定时器 定时返回值 的功能 expire := &lt;- t.C fmt.Printf(&quot;Expiration time is : %v.\\n&quot;, expire) i++ if i==4&#123; //结束的时候调用关闭 t.Stop() return &#125; &#125;&#125; 5.WaitGroup控制多个goroutine同时完成 6.协程退出处理 chan通知退出、 WithTimeout 超时自动取消方法、 WithCancel 手动取消方法： 退出最终都是通过channel通知了channel来结束协程的","categories":[{"name":"GO","slug":"GO","permalink":"https://tonywang1.github.io/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"https://tonywang1.github.io/tags/GO/"}]},{"title":"GRPC使用","slug":"2019/10/12/grpc","date":"2019-10-12T15:41:13.000Z","updated":"2019-11-18T10:00:29.536Z","comments":true,"path":"2019/10/12/you_know_grpc/","link":"","permalink":"https://tonywang1.github.io/2019/10/12/you_know_grpc/","excerpt":"","text":"GRPC初识 1.什么是GRPCGRPC是谷歌开源的高性能，跨语言的RPC框架，基于http2协议，交换描述语言为protobuf 2.GRPC描述与说明 GRPC的客户端可以直接调用服务端的方法，在任何的机器上，就像调用本地方法一样，因此利用GRPC可以更加方便的创建分布式的应用和服务。 GRPC需要定义一个服务，并说明服务的方法和返回值，然后Server方实现这个接口并运行GRPC服务去处理客户端的调用，客户端可以使用stub去调用服务端的接口（方法是一样的） 3.什么地方适合用GBPC 低延时、高可用的分布式系统； 移动端与云服务端的通讯； 使用protobuf，独立于语言的协议，支持多语言之间的通讯； 可以分层扩展，如：身份验证，负载均衡，日志记录，监控等。 服务端通信用的比较多 4.在java中如何使用GBPC 使用protobuf定义接口,即proto描述文件 使用maven的编译插件编译proto文件，生成对应的java文件 启动Server端，监听指定的端口 启动一个或者多个Client，去调用服务端暴露的接口 5.示例代码实例代码spring集成GRPC实例代码注意启动项目的时候需要修改spring-boot-starter-grpc对应的版本为对应模块的版本 6.主要参考 GRPC代码库 GRPC文档","categories":[{"name":"GRPC","slug":"GRPC","permalink":"https://tonywang1.github.io/categories/GRPC/"}],"tags":[{"name":"GRPC","slug":"GRPC","permalink":"https://tonywang1.github.io/tags/GRPC/"}]},{"title":"RESOURCE插件说明","slug":"2019/09/17/MAVEN-resource插件","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-24T08:20:15.479Z","comments":true,"path":"2019/09/18/maven_plugin_resource/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/maven_plugin_resource/","excerpt":"","text":"#RESOURCE插件说明 ##1插件说明 官方说明 resources:resources标签全名为org.apache.maven.plugins:maven-resources-plugin:3.1.0:resources即plugin中配置的资源的插件和resource标签的是同样的东西 资源插件会拷贝对应的资源根据resource标签的设置 ##2插件种类Resources插件目标有三个，主要的不同点在于：拷贝资源中的一些默认值和文件的输出目录不同 resources:resources:拷贝main resources到main output directory,它绑定了process-resources生命周期阶段，当执行Compiler:compile插件目标前就会自动执行此阶段。 resources:testResources：拷贝test resources到test output directory，它绑定了process-test-resources生命周期阶段，当执行surefire:test插件目标前就会执行此阶段 resources:copy-resources：需要自己手动配置去拷贝文件，拷贝资源去输出目录。 ##3为什么要有resource插件项目中文件通常有两种： 1 需要编译的java文件 2 不需要编译的资源文件 这两种文件通过不同的插件分别处理，其中第二种资源文件就是需要resource插件处理 ##4resource插件能解决什么问题？ 资源文件拷贝目录的设置 - 代码4.2 插件读取配置的编码情况 - 代码4.1 过滤器的设置 - 代码4.3 精确控制资源拷贝- 代码4.4 排除过滤 - 代码4.5 copy-resources 主目录中某些资源的拷贝 - 代码4.6 123456789101112代码4.1&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1234567891011代码4.2&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources1&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources2&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 123456789101112代码4.3&lt;build&gt; &lt;filters&gt; &lt;filter&gt;filter-values.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 12345678910111213141516代码4.4 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.txt&lt;/include&gt; &lt;include&gt;**/*.rtf&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.bmp&lt;/exclude&gt; &lt;exclude&gt;**/*.jpg&lt;/exclude&gt; &lt;exclude&gt;**/*.jpeg&lt;/exclude&gt; &lt;exclude&gt;**/*.gif&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resources&gt; 123456789101112131415代码4.5&lt;!-- 过滤后缀为pdf和swf的文件 --&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;nonFilteredFileExtensions&gt; &lt;nonFilteredFileExtension&gt;pdf&lt;/nonFilteredFileExtension&gt; &lt;nonFilteredFileExtension&gt;swf&lt;/nonFilteredFileExtension&gt; &lt;/nonFilteredFileExtensions&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;plugins&gt; 123456789101112131415161718192021222324代码4.6 &lt;!-- 资源目录 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，只处理如下配置中包含的资源类型 --&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，不处理如下配置中包含的资源类型（剔除下如下配置中包含的资源类型）--&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.yaml&lt;/exclude&gt; &lt;/excludes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，指定处理后的资源文件输出目录，默认是$&#123;build.outputDirectory&#125;指定的目录--&gt; &lt;!--&lt;targetPath&gt;$&#123;build.outputDirectory&#125;&lt;/targetPath&gt; --&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，是否对主资源目录开启资源过滤 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;","categories":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/categories/MAVEN/"}],"tags":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/tags/MAVEN/"}]},{"title":"cron使用","slug":"2019/09/24/CRON学习","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-25T06:21:48.816Z","comments":true,"path":"2019/09/18/linux_cron/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/linux_cron/","excerpt":"","text":"CRON使用 1.什么是cron表达式 Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式 2 基本语法corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份 3 基本语法中字段含义 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 年(可选，留空)（Year） 1970~2099 , - * / 四个字符 （1）*：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。 （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。 （3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 （4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. （5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 （6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 （7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 （8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 （9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 4 常用样例（1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业（3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点（5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时（6）0 0 12 ? * WED 表示每个星期三中午12点（7）0 0 12 * * ? 每天中午12点触发（8）0 15 10 ? * * 每天上午10:15触发（9）0 15 10 * * ? 每天上午10:15触发（10）0 15 10 * * ? * 每天上午10:15触发（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发（14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发（18）0 15 10 15 * ? 每月15日上午10:15触发（19）0 15 10 L * ? 每月最后一日的上午10:15触发（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发（23）*/5 * * * * ? 每5秒执行一次（24）0 */1 * * * ? 每隔一分钟执行一次（25）0 1 * * * ? 每个小时的1分钟执行一次，如1点1分、2点1分（26）0 0 1 * * ? 每天零晨1点执行（26）0 0 2 * * ? 每天零晨2点执行（27）0 0 1 20 * ? 每个月20日零晨1点执行","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/categories/LINUX/"}],"tags":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/tags/LINUX/"},{"name":"CRON","slug":"CRON","permalink":"https://tonywang1.github.io/tags/CRON/"}]},{"title":"mysql-sql执行流程","slug":"2019/09/27/MYSQL-SQL执行流程","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-27T09:14:20.979Z","comments":true,"path":"2019/09/18/linux_cron/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/linux_cron/","excerpt":"","text":"MYSQL-SQL执行流程 1.SQL的执行流程 词法分析-&gt;语法分析-解析树-预处理-检查权限-新解析树-查询优化器-执行计划-存储引擎获取数据 1.SQL 的关键字执行的流程如何 1）执行的SQL语句-每一步执行的输出，是下一步的输入 1234567891011121314 SELECT DISTINCT &lt; select_list &gt;FROM &lt; left_table &gt; &lt; join_type &gt;JOIN &lt; right_table &gt; ON &lt; join_condition &gt;WHERE &lt; where_condition &gt;GROUP BY &lt; group_by_list &gt;HAVING &lt; having_condition &gt;ORDER BY &lt; order_by_condition &gt;LIMIT &lt; limit_number &gt; 2)实际执行流程 12345678910FROM &lt;left_table&gt;ON &lt;join_condition&gt;&lt;join_type&gt; JOIN &lt;right_table&gt;WHERE &lt;where_condition&gt;GROUP BY &lt;group_by_list&gt;HAVING &lt;having_condition&gt;SELECT DISTINCT &lt;select_list&gt;ORDER BY &lt;order_by_condition&gt;LIMIT &lt;limit_number&gt; 3 执行顺序实例1）准备工作 123456789101112131415161718CREATE DATABASE /*!32312 IF NOT EXISTS*/`test1db` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `test1db`;CREATE TABLE `table1` ( `uid` varchar(10) NOT NULL, `name` varchar(10) NOT NULL, PRIMARY KEY (`uid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `table1`(`uid`,`name`) values (&apos;aaa&apos;,&apos;mike&apos;),(&apos;bbb&apos;,&apos;jack&apos;),(&apos;ccc&apos;,&apos;mike&apos;),(&apos;ddd&apos;,&apos;mike&apos;);CREATE TABLE `table2` ( `oid` int(11) NOT NULL AUTO_INCREMENT, `uid` varchar(10) DEFAULT NULL, `old` int(11) DEFAULT NULL COMMENT &apos;年龄&apos;, PRIMARY KEY (`oid`)) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;insert into `table2`(`oid`,`uid`,`old`) values (1,&apos;aaa&apos;,2),(2,&apos;aaa&apos;,1),(3,&apos;bbb&apos;,3),(4,&apos;bbb&apos;,4),(5,&apos;bbb&apos;,5),(6,&apos;ccc&apos;,6),(7,NULL,7); 2）最终的执行结果 123456789101112131415SELECT a.uid, count(b.oid) AS total FROM table1 AS aLEFT JOIN table2 AS b ON a.uid = b.uidWHERE a. NAME = &apos;mike&apos;GROUP BY a.uidHAVING count(b.oid) &lt; 2ORDER BY total DESCLIMIT 1; 3）执行FROM关键字-笛卡尔积 123select * from table1 a left join table2 b on a.uid=b.uid 4) ON关键字过滤-v-4 1select * from table1 a join table2 b on a.uid=b.uid ; 5)如果使用了外连接(LEFT,RIGHT,FULL)，主表（保留表）中的不符合ON条件的列也会被加入到这一步的执行结果中-生成新的虚拟表v-5 6）WHERE条件过滤 -v-6对于上面的执行结果，满足WHERE条件的结果集的数据，会生成新的虚拟表 v-6 1234select * from table1 a left join table2 b on a.uid=b.uid where a.name=&apos;mike&apos; 注意：ON和where条件过滤的区别 1 在inner join的时候 ，两者查询的结果一样2 在外连接(LEFT,RIGHT,FULL)查询的时候，on对关联表进行条件过滤，然后在与主表进行关联，这个过程中这个查询条件对主表不会有影响3 在外连接(LEFT,RIGHT,FULL)查询的时候，where 条件过滤，是对连接后的整个临时表进行过滤，不分主从 123查询示例：select * from table1 a left join table2 b on a.uid=b.uid and b.oid='1' ; select * from table1 a left join table2 b on a.uid=b.uid where b.oid='1' ; 总结 主表进行过滤必须放到WHERE条件后，从表过滤如果先过滤后链接则条件放到on后面，如果先链接在过滤则放到WHERE条件后 7）GROUP BY 关键字进行过滤 这个会对表 v-6中的表的某些字段进行分组，他对于后面的SELECT,和HAVING所用到的列必须包含在GROUP BY 中，对于没有出现的必须进行聚合运算 对于mysql上面的限制条件可以忽略，但是select字段中没有出现在group by中的字段，会随机选择一个值。 8)HAVING 关键字作用：对分组后的数据进行过滤，满足条件的数据放到下一个虚拟表中-v-8 123456789101112SELECT a.uid, count(b.oid) AS total FROM table1 AS aLEFT JOIN table2 AS b ON a.uid = b.uidWHERE a. NAME = 'mike'GROUP BY a.uidHAVING count(b.oid) &lt; 1 9)SELECT 对select子句进行处理1 - 计算select子句的表达式2 - 如果有 DISTINCT，则进行去重 10）ORDER BY-根据ORDER BY 子句的条件对结果进行排序唯一可使用SELECT中别名的地方 1234567891011121314SELECT a.uid, count(b.oid) AS total FROM table1 AS aLEFT JOIN table2 AS b ON a.uid = b.uidWHERE a. NAME = &apos;mike&apos;GROUP BY a.uidHAVING count(b.oid) &lt; 1ORDER BY total DESC 11) LIMIT-子句从上一步得到的虚拟表中选出从指定位置开始的指定行数据 2 SQL中关联表on后面的条件与where后面条件有什么不同详细见上面的6 ##3.同一个字段不同值的统计处理查询一个用户有多少条年龄数据： 12345select name, sum(case when (old is not null) then 1 else 0 end ) &apos;个数&apos;from table1 a left join table2 b on a.uid=b.uid group by a.name ;","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://tonywang1.github.io/categories/MYSQL/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://tonywang1.github.io/tags/MYSQL/"},{"name":"SQL","slug":"SQL","permalink":"https://tonywang1.github.io/tags/SQL/"}]},{"title":"CURL使用","slug":"2019/09/24/CURL命令记录","date":"2019-09-17T20:28:36.000Z","updated":"2020-07-18T07:01:52.197Z","comments":true,"path":"2019/09/18/linux_curl/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/linux_curl/","excerpt":"","text":"CURL使用 1.curl作用 curl是一个利用URL规则在命令行下工作的文件传输工具 2语法 curl [option] [url] 3实例 发送get、post请求-代码3.1 发送带有参数的get和post请求 - 3.2 查看请求的整个请求链路-调试谁用 - 3.3 发送带有header请求 - 4.4 发送设置host的请求 -4.4 12代码3.1curl -i(返回头信息) -X POST/Get http//www.baidu.com 12345代码3.2- 发送applicationjson数据- curl -H &quot;Content-Type:application/json&quot; -X POST -d &apos;&#123;&quot;user&quot;: &quot;admin&quot;, &quot;passwd&quot;:&quot;12345678&quot;&#125;&apos; https://proxy.mimvp1.com/login- 普通数据提交- curl -d &quot;param1=value1&amp;param2=value2&quot; -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -X POST http://localhost:3001/data 12代码3.3curl -X POST/Get http//www.baidu.com -xvo /usr/null | python -m json.tool 12代码4.4curl &apos;http://localhost/hadoop1/clusters/list?page=1&amp;pageSize=50&amp;total=0&amp;tokenId=tokenId_a218_4ab8_8404_3ac9a4b63d2c&apos; -H &apos;host:bd1prod.localhost.com","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/categories/LINUX/"}],"tags":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/tags/LINUX/"},{"name":"CURL","slug":"CURL","permalink":"https://tonywang1.github.io/tags/CURL/"}]},{"title":"MAVEN插件总览","slug":"2019/09/17/MAVEN插件","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-24T08:20:50.663Z","comments":true,"path":"2019/09/18/maven_plugin/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/maven_plugin/","excerpt":"","text":"maven插件知识总览 1.对于maven插件的了解插件官网： http://maven.apache.org/plugins/index.html Maven 本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成。如编译源代码是由 maven-compiler-plugin完成的，每个任务阶段对应了一个插件目标（goal），每个插件会有一个或者多个目标，如maven- compiler-plugin的compile目标用来编译位于src/main/java/目录下的主源码，testCompile目标用来编译位于src/test/java/目录下的测试源码 2.常用插件1） maven-antrun-pluginhttp://maven.apache.org/plugins/maven-antrun-plugin/ 2） maven-archetype-pluginhttp://maven.apache.org/archetype/maven-archetype-plugin/ 3） maven-assembly-pluginhttp://maven.apache.org/plugins/maven-antrun-plugin/ 4） maven-dependency-pluginhttp://maven.apache.org/plugins/maven-dependency-plugin/ maven-dependency-plugin最大的用途是帮助分析项目依赖，dependency:list能够列出项目最终解析到的依赖列表，dependency:tree能进一步的描绘项目依赖树，dependency:analyze可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin还有很多目标帮助你操作依赖文件，例如dependency:copy-dependencies能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面。 5）maven-help-plugin官网插件地址：http://maven.apache.org/plugins/maven-help-plugin/ maven-help-plugin是一个小巧的辅助工具，最简单的help:system可以打印所有可用的环境变量和Java系统属性。help:effective-pom和help:effective-settings最 为有用，它们分别打印项目的有效POM和有效settings，有效POM是指合并了所有父POM（包括Super POM）后的XML，当你不确定POM的某些信息从何而来时，就可以查看有效POM。有效settings同理，特别是当你发现自己配置的 settings.xml没有生效时，就可以用help:effective-settings来验证。此外，maven-help-plugin的describe目标可以帮助你描述任何一个Maven插件的信息，还有all-profiles目标和active-profiles目标帮助查看项目的Profile。 6）maven-resources-plugin 官网插件地址：http://maven.apache.org/plugins/maven-resources-plugin 作用：为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。此外，资源文件过滤也是Maven的一大特性，你可以在资源文件中使用${propertyName}形式的Maven属性，然后配置maven-resources-plugin开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者Profile传入属性的值，以实现更为灵活的构建。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546代码6.1 设置资源文件编码&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!--配置资源文件编码--&gt; &lt;/configuration&gt;&lt;/plugin&gt;``` ### 7）versions-maven-plugin 官网插件地址：[http://mojo.codehaus.org/versions-maven-plugin/](http://mojo.codehaus.org/versions-maven-plugin/) 很多Maven用户遇到过这样一个问题，当项目包含大量模块的时候，为他们集体更新版本就变成一件烦人的事情，到底有没有自动化工具能帮助完成这件 事情呢？（当然你可以使用sed之类的文本操作工具，不过不在本文讨论范围）答案是肯定的，versions-maven- plugin提供了很多目标帮助你管理Maven项目的各种版本信息。例如最常用的，命令 mvn versions:set -DnewVersion=1.1-SNAPSHOT 就能帮助你把所有模块的版本更新到1.1-SNAPSHOT。该插件还提供了其他一些很有用的目标，display-dependency- updates能告诉你项目依赖有哪些可用的更新；类似的display-plugin-updates能告诉你可用的插件更新；然后use- latest-versions能自动帮你将所有依赖升级到最新版本。最后，如果你对所做的更改满意，则可以使用 mvn versions:commit 提交，不满意的话也可以使用 mvn versions:revert 进行撤销。## 8 war包相关的例子-执行打war阶段的时候自动执行- 官网地址：[https://maven.apache.org/plugins/maven-war-plugin](https://maven.apache.org/plugins/maven-war-plugin/)- 所有的路径都是相对于pom文件的路径 &lt;!-- maven-war-plugin：mvn install可以将项目打成war包 --&gt;```xml&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;&lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;!-- 需要打包的目标文件路径 --&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt;&lt;!-- 指定build资源具体目录，默认是base directory。 --&gt; &lt;targetPath&gt;WEB-INF&lt;/targetPath&gt; &lt;!-- 打包的文件叫什么 --&gt; &lt;includes&gt; &lt;include&gt;**/web.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;!-- 打包后放在这个目录下 --&gt;&lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt; &lt;webXml&gt;src/main/webapp/WEB-INF/web.xml&lt;/webXml&gt;&lt;/configuration&gt;&lt;/plugin&gt; 123456789101112131415 说明：指定打包的目录和对应的web.xml文件&lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt;&lt;/plugin&gt; 9 编译插件使用实例-执行编译阶段的时候会自动执行 官网地址:https://maven.apache.org/plugins/maven-compiler-plugin/ 使用实例：12345678910111213141516 &lt;plugin&gt; &lt;!-- 指定maven编译的jdk版本,如果不指定,maven3默认用jdk 1.5 maven2默认用jdk1.3 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- 一般而言，target与source是保持一致的，但是，有时候为了让程序能在其他版本的jdk中运行(对于低版本目标jdk，源代码中不能使用低版本jdk中不支持的语法)，会存在target不同于source的情况 --&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!-- 源代码使用的JDK版本 --&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt;&lt;!-- 字符集编码 --&gt; &lt;skipTests&gt;true&lt;/skipTests&gt;&lt;!-- 跳过测试 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; 10 spring打可执行的插件 官网地址:https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html spring打包实例12345678&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;主类&lt;/mainClass&gt; &lt;/configuration&gt;&lt;/plugin&gt;","categories":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/categories/MAVEN/"}],"tags":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/tags/MAVEN/"}]},{"title":"maven浅尝辄止1","slug":"2019/09/17/maven浅尝辄止","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-24T08:21:41.628Z","comments":true,"path":"2019/09/18/maven1/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/maven1/","excerpt":"","text":"maven的认识 1.什么是maven？ Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。参考 2. maven能帮我们解决什么问题 项目统一构建 - 统一生成项目结构 jar包统一管理 - 自动下载jar包、对应的jar包的依赖、jar包不同版本冲突问题、jar包版本统一管理 项目版本统一管理 - Release和SNAPSHOT版本即稳定版本和快照版本 项目的编译、测试、打包 、安装、发布等管理 项目不同环境配置的管理 不同项目之间依赖管理 3. maven中如何使用profile来解决项目不同环境的问题profile使用原理：通过激活某个profile来加载对应的属性，达到不同环境加载不同属性作用 1、命令激活：通过打包的时候使用 -p profile名称指定该profile对应的环境的变量2、属性加载：不同profile定义不同属性或者加载不同的属性文件-代码3.13、属性引用：在2中定义的属性或者加载的属性文件的内容可以通过${定义的属性名称}引用4、属性文件赋值：利用2中加载属性与resource中的filter连用，达到对属性文件赋值的作用，即代码2中的属性文件中所有带有${定义的属性名称}引用的变量，在编译阶段都会用实际的属性代替，代码3.2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051代码3.1&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 默认激活开发配制，使用config-dev.properties来替换设置过虑的资源文件中的$&#123;key&#125; --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-dev.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-test.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-prod.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;``` ``` xml*** 代码3.2-这里filtering属性=true代表所有资源文件中带有placehoder的变量都会用maven的便来给你代替 ***&lt;resources&gt; &lt;!-- Resource Filter --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 4. maven中如何使用resource打不同的资源文件来解决不同环境问题 默认属性文件目录处理：根据profile属性拼接并打包对应的配置文件如代码4.1 源文件目录下配置文件处理：拷贝java源文件目录下的配置文件 1234567891011121314151617181920212223代码4.1&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;excludes&gt; &lt;exclude&gt;application.properties&lt;/exclude&gt; &lt;exclude&gt;application-dev.properties&lt;/exclude&gt; &lt;exclude&gt;application-test.properties&lt;/exclude&gt; &lt;exclude&gt;application-prod.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;application.properties&lt;/include&gt; &lt;include&gt;application-$&#123;profiles.active&#125;.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt;&lt;/resources&gt; 123456789101112131415161718192021代码4.2&lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，只处理如下配置中包含的资源类型 --&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，不处理如下配置中包含的资源类型（剔除下如下配置中包含的资源类型）--&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.yaml&lt;/exclude&gt; &lt;/excludes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，指定处理后的资源文件输出目录，默认是$&#123;build.outputDirectory&#125;指定的目录--&gt; &lt;!--&lt;targetPath&gt;$&#123;build.outputDirectory&#125;&lt;/targetPath&gt; --&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，是否对主资源目录开启资源过滤 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; 4. maven中父子项目依赖关系父子项目依赖的多模块处理作用: 复杂项目通过合理拆分达到代码复用、方便管理 父项目设置-如代码4.1 packaging=pommodules中包含所有子项目，里面的名字为各个项目的artifactId参数 子项目设置-如代码4.2，里面的参数为父项目的相应值，子项目不指定groupId，会自动从父项目中继承 子项目之家可以通过dependency来进行引用 123456789代码4.1&lt;packaging&gt;pom&lt;/packaging&gt;&lt;modules&gt; &lt;module&gt;pojo&lt;/module&gt; &lt;module&gt;web&lt;/module&gt; &lt;module&gt;dao&lt;/module&gt; &lt;module&gt;service&lt;/module&gt;&lt;/modules&gt; 123456代码4.2&lt;parent&gt; &lt;artifactId&gt;online_retailers&lt;/artifactId&gt; &lt;groupId&gt;com.hd&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 5.maven中必要节点的作用说明 filters：定义指定filter属性的位置，例如filter元素赋值filters/filter1.properties,那么这个文件里面就可以定义name=value对，这个name=value对的值就可以在工程pom中通过${name}引用，默认的filter目录是${basedir}/src/main/fiters/ packing：主要打什么类型的包-pom、jar(默认)、war pom - 父类型都为pom jar - 内部调用或者服务使用 war - 部署的项目 modelVersion:模型版本，暂时固定为4.0.0 groupId： 1 项目构建的时候第一次会根据这个参数构建目录2 打包后jar位置为：repository后面的目录为-groupId所设置的目录 、在后面为artifactId，在后面为版本version ，所以groupId+artifactId+version决定了jar包的位置 artifactId：项目的唯一ID version：版本号，分release和snapshot版本 name:项目的显示名称，idea的maven视图中会显示这个名称 6. maven中内置的属性变量内置属性(Maven预定义,用户可以直接使用) ${basedir}表示项目根目录,即包含pom.xml文件的目录; ${version}表示项目版本; ${project.basedir}同${basedir}; ${project.baseUri}表示项目文件地址; ${maven.build.timestamp}表示项目构件开始时间; POM属性 ${project.build.directory}表示主源码路径 ${project.build.sourceEncoding}表示主源码的编码格式 ${project.build.sourceDirectory}表示主源码路径 ${project.build.finalName}表示输出文件名称 ${project.version}表示项目版本,与${version}相同 Java系统属性(所有的Java系统属性都可以使用Maven属性引用) 使用mvn help:system命令可查看所有的Java系统属性; System.getProperties()可得到所有的Java属性; ${user.home}表示用户目录 环境变量属性(所有的环境变量都可以用以env.开头的Maven属性引用) -使用mvn help:system命令可查看所有环境变量; ${env.JAVA_HOME}表示JAVA_HOME环境变量的值; 8.maven的生命周期，以及执行规则1） 生命周期 Maven有三个独立的生命周期为：clean-项目清理、default-项目构建、site-站点生成 2）生命周期对应的阶段clean生命周期包含三个阶段 pre-clean：执行一些需要在clean之前完成的工作 clean：移除所有上一次构建生成的文件 post-clean：执行一些需要在clean之后立刻完成的工作 default生命周期的阶段列表： validate：验证 initialize：initialize build state, e.g. set properties or create directories. generate-sources：generate any source code for inclusion in compilation. process-sources：process the source code, for example to filter any values. generate-resources：处理资源文件 process-resources：复制并处理资源文件，至目标目录，准备打包 compile：编译项目源代码 process-classes：post-process the generated files from compilation, for example to do bytecode enhancement on Java classes. generate-test-sources：generate any test source code for inclusion in compilation. process-test-sources：process the test source code, for example to filter any values. generate-test-resources create resources for testing. process-test-resources 复制并处理资源文件，至目标测试目录 test-compile 编译测试源代码 process-test-classes： post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above. test：使用合适的单元测试框架运行测试，这些测试代码不会被打包或者部署。 prepare-package：perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above) package：接受编译好的代码，打包成可发布的格式，如jar pre-integration-test：perform actions required before integration tests are executed. This may involve things such as setting up the required environment. integration-test：process and deploy the package if necessary into an environment where integration tests can be run. post-integration-test：perform actions required after integration tests have been executed. This may including cleaning up the environment. verify run any checks to verify the package is valid and meets quality criteria. install：将包安装至本地仓库，以让其他项目依赖 deploy 3) 生命周期中阶段的执行关系 某个特定生命周期中，生命周期后面的阶段执行，都会伴随着前面阶段的执行 不同生命周期之间不依赖 4）生命周期、阶段、插件关系一个生命周期中有多个阶段，一个阶段可以绑定一个或者多个插件 9.SNAPSHOT版本和release版本区别 Release版本则代表稳定的版本 只要版本不变，则打包的时候会用本地库中的版本，不会去远程服务器上更新。 Snapshot版本代表不稳定、尚处于开发中的版本 项目每次构建的时候，Maven会去远程repository下载snapshot的最新版本，如果被依赖的snapshot版本不断更新，则项目每次构建的时候的结果都会不一样 10.依赖包的scope取值说明 compile，缺省值，适用于所有阶段，会随着项目一起发布。 provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 11.自定义属性使用标签“properties”中定义的属性","categories":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/categories/MAVEN/"}],"tags":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/tags/MAVEN/"}]},{"title":"JAVA时间总结","slug":"2019/09/24/JAVA日期时间","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-24T09:55:00.401Z","comments":true,"path":"2019/09/18/java_date/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/java_date/","excerpt":"","text":"JAVA时间总结 1.UTC(世界标准时间)什么是utc时间 即协调世界时。UTC是以原子时秒长为基础，在时刻上尽量接近于GMT的一种时间计量系统。为确保UTC与GMT相差不会超过0.9秒，在有需要的情况下会在UTC内加上正或负闰秒。UTC现在作为世界标准时间使用 2.GMT(格林尼治平时) 即格林尼治标准时间，也就是世界时。GMT的正午是指当太阳横穿格林尼治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致GMT不精确，现在已经不再作为世界标准时间使用。 UTC和GMT时间误差不超过0.9秒,即两者基本相同 3.CST(北京时间) 北京时间，China Standard Time，中国标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8 java日期工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544public class DateUtils &#123; private static final SimpleDateFormat datetimeFormat = new SimpleDateFormat( \"yyyy-MM-dd HH:mm:ss\"); private static final SimpleDateFormat dateFormat = new SimpleDateFormat( \"yyyy-MM-dd\"); private static final SimpleDateFormat timeFormat = new SimpleDateFormat( \"HH:mm:ss\"); /** * 获得当前日期时间 * &lt;p&gt; * 日期时间格式yyyy-MM-dd HH:mm:ss * * @return */ public static String currentDatetime() &#123; return datetimeFormat.format(now()); &#125; /** * 格式化日期时间 * &lt;p&gt; * 日期时间格式yyyy-MM-dd HH:mm:ss * * @return */ public static String formatDatetime(Date date) &#123; return datetimeFormat.format(date); &#125; /** * 格式化日期时间 * * @param date * @param pattern * 格式化模式，详见&#123;@link SimpleDateFormat&#125;构造器 * &lt;code&gt;SimpleDateFormat(String pattern)&lt;/code&gt; * @return */ public static String formatDatetime(Date date, String pattern) &#123; SimpleDateFormat customFormat = (SimpleDateFormat) datetimeFormat .clone(); customFormat.applyPattern(pattern); return customFormat.format(date); &#125; /** * 格式化 时间戳 * @param date * @param pattern * @return */ public static String formatDatetime(Timestamp date, String pattern) &#123; SimpleDateFormat customFormat = (SimpleDateFormat) datetimeFormat .clone(); customFormat.applyPattern(pattern); return customFormat.format(date); &#125; /** * 字符串日期 格式化后 变为字符串形式 * @param date * @param pattern * @return */ public static String formatDatetime(String date, String pattern) &#123; Date date2 = null; try &#123; SimpleDateFormat customFormat = (SimpleDateFormat) datetimeFormat .clone(); customFormat.applyPattern(pattern); date2 = customFormat.parse(date ); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return formatDatetime(date2, pattern); &#125; /** * * @param * @return */ public static long getCurTimestamp(Date date)&#123; String curDate = formatDatetime( date, \"yyyyMMddHHmmss\" ) ; return Long.parseLong( curDate) ; &#125; /** * 字符串转换成日期 * @param * @return pattern 日期格式 \"yyyy-MM-dd HH:mm:ss\" */ public static Date strToDate(String dateStr,String pattern) &#123; SimpleDateFormat format = new SimpleDateFormat(pattern); Date date = null; try &#123; date = format.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; /** * 获得当前日期 * &lt;p&gt; * 日期格式yyyy-MM-dd * * @return */ public static String currentDate() &#123; return dateFormat.format(now()); &#125; /** * 格式化日期 * &lt;p&gt; * 日期格式yyyy-MM-dd * * @return */ public static String formatDate(Date date) &#123; return dateFormat.format(date); &#125; /** * 获得当前时间 * &lt;p&gt; * 时间格式HH:mm:ss * * @return */ public static String currentTime() &#123; return timeFormat.format(now()); &#125; /** * 格式化时间 * &lt;p&gt; * 时间格式HH:mm:ss * * @return */ public static String formatTime(Date date) &#123; return timeFormat.format(date); &#125; /** * 获得当前时间的&lt;code&gt;java.util.Date&lt;/code&gt;对象 * * @return */ public static Date now() &#123; return new Date(); &#125; public static Calendar calendar() &#123; Calendar cal = GregorianCalendar.getInstance(Locale.CHINESE); cal.setFirstDayOfWeek(Calendar.MONDAY); return cal; &#125; /** * 获得当前时间的毫秒数 * &lt;p&gt; * 详见&#123;@link System#currentTimeMillis()&#125; * * @return */ public static long millis() &#123; return System.currentTimeMillis(); &#125; /** * * 获得当前Chinese月份 * * @return */ public static int month() &#123; return calendar().get(Calendar.MONTH) + 1; &#125; /** * 获得月份中的第几天 * * @return */ public static int dayOfMonth() &#123; return calendar().get(Calendar.DAY_OF_MONTH); &#125; /** * 今天是星期的第几天 * * @return */ public static int dayOfWeek() &#123; return calendar().get(Calendar.DAY_OF_WEEK); &#125; /** * 今天是年中的第几天 * * @return */ public static int dayOfYear() &#123; return calendar().get(Calendar.DAY_OF_YEAR); &#125; /** *判断原日期是否在目标日期之前 * * @param src * @param dst * @return */ public static boolean isBefore(Date src, Date dst) &#123; return src.before(dst); &#125; /** *判断原日期是否在目标日期之后 * * @param src * @param dst * @return */ public static boolean isAfter(Date src, Date dst) &#123; return src.after(dst); &#125; /** *判断两日期是否相同 * * @param date1 * @param date2 * @return */ public static boolean isEqual(Date date1, Date date2) &#123; return date1.compareTo(date2) == 0; &#125; /** * 判断某个日期是否在某个日期范围 * * @param beginDate * 日期范围开始 * @param endDate * 日期范围结束 * @param src * 需要判断的日期 * @return */ public static boolean between(Date beginDate, Date endDate, Date src) &#123; return beginDate.before(src) &amp;&amp; endDate.after(src); &#125; /** * 获得当前月的最后一天 * &lt;p&gt; * HH:mm:ss为0，毫秒为999 * * @return */ public static Date lastDayOfMonth() &#123; Calendar cal = calendar(); cal.set(Calendar.DAY_OF_MONTH, 0); // M月置零 cal.set(Calendar.HOUR_OF_DAY, 0);// H置零 cal.set(Calendar.MINUTE, 0);// m置零 cal.set(Calendar.SECOND, 0);// s置零 cal.set(Calendar.MILLISECOND, 0);// S置零 cal.set(Calendar.MONTH, cal.get(Calendar.MONTH) + 1);// 月份+1 cal.set(Calendar.MILLISECOND, -1);// 毫秒-1 return cal.getTime(); &#125; /** * 获得当前月的第一天 * &lt;p&gt; * HH:mm:ss SS为零 * * @return */ public static Date firstDayOfMonth() &#123; Calendar cal = calendar(); cal.set(Calendar.DAY_OF_MONTH, 1); // M月置1 cal.set(Calendar.HOUR_OF_DAY, 0);// H置零 cal.set(Calendar.MINUTE, 0);// m置零 cal.set(Calendar.SECOND, 0);// s置零 cal.set(Calendar.MILLISECOND, 0);// S置零 return cal.getTime(); &#125; private static Date weekDay(int week) &#123; Calendar cal = calendar(); cal.set(Calendar.DAY_OF_WEEK, week); return cal.getTime(); &#125; /** * 获得周五日期 * &lt;p&gt; * 注：日历工厂方法&#123;@link #calendar()&#125;设置类每个星期的第一天为Monday，US等每星期第一天为sunday * * @return */ public static Date friday() &#123; return weekDay(Calendar.FRIDAY); &#125; /** * 获得周六日期 * &lt;p&gt; * 注：日历工厂方法&#123;@link #calendar()&#125;设置类每个星期的第一天为Monday，US等每星期第一天为sunday * * @return */ public static Date saturday() &#123; return weekDay(Calendar.SATURDAY); &#125; /** * 获得周日日期 * &lt;p&gt; * 注：日历工厂方法&#123;@link #calendar()&#125;设置类每个星期的第一天为Monday，US等每星期第一天为sunday * * @return */ public static Date sunday() &#123; return weekDay(Calendar.SUNDAY); &#125; /** * 将字符串日期时间转换成java.util.Date类型 * &lt;p&gt; * 日期时间格式yyyy-MM-dd HH:mm:ss * * @param datetime * @return */ public static Date parseDatetime(String datetime) throws ParseException &#123; return datetimeFormat.parse(datetime); &#125; /** * 将字符串日期转换成java.util.Date类型 *&lt;p&gt; * 日期时间格式yyyy-MM-dd * * @param date * @return * @throws ParseException */ public static Date parseDate(String date) throws ParseException &#123; return dateFormat.parse(date); &#125; /** * 将字符串日期转换成java.util.Date类型 *&lt;p&gt; * 时间格式 HH:mm:ss * * @param time * @return * @throws ParseException */ public static Date parseTime(String time) throws ParseException &#123; return timeFormat.parse(time); &#125; /** * 根据自定义pattern将字符串日期转换成java.util.Date类型 * * @param datetime * @param pattern * @return * @throws ParseException */ public static Date parseDatetime(String datetime, String pattern) throws ParseException &#123; SimpleDateFormat format = (SimpleDateFormat) datetimeFormat.clone(); format.applyPattern(pattern); return format.parse(datetime); &#125; //北京时间转为utc时间，oozie 使用 public static String BJ2UTC(String time) &#123; Date date = null; try &#123; date = parseDatetime(time); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; Calendar cal = Calendar.getInstance( ); cal.setTime(date);//date 换成已经已知的Date对象 cal.add(Calendar.HOUR_OF_DAY, -8);// before 8 hour SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\"); return sdf.format(cal.getTime( )); &#125; /* * 将时间戳转换为时间 */ public static String stampToDate(Long timestamp)&#123; Date date = new Date(timestamp); return formatDatetime(date) ; &#125; /** * 得到最近一个月的所有日期 * @param d 传入的日期 * @return */ public static List&lt;String&gt; getDaysMonthByDate(Date d,String pattern)//根据传入的日期获取一个月内的所有日期 &#123; List&lt;String&gt; lst=new ArrayList&lt;String&gt;(); Date startDate = getOneMonthDate(d); while (!startDate.after(d)) &#123; lst.add(formatDatetime(startDate,pattern)); startDate = getNext(startDate); &#125; return lst; &#125; /** * 得到一个月前的日期 * @param d * @return */ private static Date getOneMonthDate(Date d )&#123; Calendar calendar = Calendar.getInstance(); calendar.setTime( d ); calendar.add( Calendar.MONTH, -1 ); calendar.add( Calendar.DAY_OF_MONTH, 1); return calendar.getTime(); &#125; /** * 当前日期+1天 * @param date * @return */ public static Date getNext(Date date) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(Calendar.DATE, 1); return calendar.getTime(); &#125; /** * * @param datetime 2017-10-01T16:00:00.000Z * @param format yyyy-MM-dd'T'HH:mm:ss.SSS'Z' * @return */ //utc 转换为 北京时间 （时间带有T分隔符的） public static Date UTC2BJ(String datetime, String format) &#123; SimpleDateFormat customFormat = (SimpleDateFormat) datetimeFormat.clone(); customFormat.applyPattern(format); customFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\") ); Date date = null; try &#123; date = customFormat.parse( datetime); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; /** * UTC 时间转化为bj时间的字符串 * @param datetime * @param format * @return */ public static String UTC2BJStr(String datetime, String format)&#123; Date date = UTC2BJ(datetime,format); return formatDatetime( date ); &#125; /** * 获取某一天的开始时间 * @param date * @return */ public static Date getDayBegin(Date date) &#123; Calendar cal = new GregorianCalendar(); cal.setTime(date); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); &#125; /** * 获取当天的结束时间 * @param date * @return */ public static Date getDayEnd(Date date) &#123; Calendar cal = new GregorianCalendar(); cal.setTime(date); cal.set(Calendar.HOUR_OF_DAY, 23); cal.set(Calendar.MINUTE, 59); cal.set(Calendar.SECOND, 59); return cal.getTime(); &#125; public static void main(String[] args) &#123;// String str = formatDatetime(\"1984-1-1 12:12:13\",\"yyyy-MM-dd\");// System.out.println(str );// Long t = millis(); String startCreateDate=\"2017-10-01T16:00:00.000Z\"; Date start = DateUtils.UTC2BJ( startCreateDate, \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\" ); System.out.println( start);// Long t = 1504681347375l;// String str = stampToDate(t );// System.out.println(t+\"===\"+ str );// // List list = getDaysMonthByDate(new Date(),\"M月d\");// for(int i=0;i&lt;list.size();i++ )&#123;// System.out.println( list.get(i));// &#125; // String str2 = BJ2UTC( \"2099-12-12 12:12:12\") ;// System.out.print(str2 ); &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"},{"name":"DATE","slug":"DATE","permalink":"https://tonywang1.github.io/tags/DATE/"}]},{"title":"深入字节","slug":"深入字节","date":"2019-09-10T20:32:15.000Z","updated":"2020-07-20T08:00:37.712Z","comments":true,"path":"2019/09/11/lean_byte/","link":"","permalink":"https://tonywang1.github.io/2019/09/11/lean_byte/","excerpt":"","text":"深入了解字节 1.为什么要写字节这个东东 做JAVA项目的时候总会碰到读写字节的过程 经常有字符串和字节互相转化的过程 每次只是知道怎么做，但是不知道为什么这样做 希望经过这篇文章整理，彻底了解这个字节以及字节和用户输入文字之间的关系。 2. 了解一下具体什么是字节 在编程的时候总会遇到字节数组，如读取一个文件时候多个字节一起读、Socket的网络编程的时候读取数据也是按照字节读取的，总会思考这个字节是什么？ 答案：字节实际上就是我们在换算单位时候用到的byte，一个byte=8位（八个0、1组成的一串二进制的数字） 3. 在java中字符串是如何转化为字节的计算机起源美国 -&gt; 美国使用英语 -&gt; 英语（数字、大小写字母、控制字符标点符号、运算字符等组成） -&gt; 8位二进制数（共255个）表示所有字符即：你每次输入一个字符-计算机会到对照表中查找对应的值(二进制、十进制) -&gt; 二进制就可以被计算机识别到此计算机可以识别人类输入的所有英文字符 -&gt; 即字符到二进制的转换 问题出现 -&gt; 非英语字符通过对照表找不到对应的值，就不能识别如何处理对应的字符，如：输入中文“您”，到对照表中找不到，计算机就不认识。那么，就需要有其他的对照表出现：即gb2312、gbk、utf-8等 一个中文转换成字符的过程是怎么样子的？ 字符：‘我’-utf-8编码-&gt;BDE4-&gt;251059（十进制）-&gt;6211（十六进制）-&gt; 1100111011010010 (二进制) ‘中’-&gt;对应的Unicode表的值4E2D（十六进制）（java使用Unicode编码）-&gt;对应的二进制100111000101101-&gt;utf-8填充规则转换-&gt;11100100 10111000 10101101 UTF-8最多可用到6个字节则二进制变为100 111000 101101一共3个部分参考链接 对于JAVA-我们编写的代码用UTF-8（这个是发文件编码）-&gt;类加载以后会统一用UTF-16进行编码(内存中统一用UTF-16表示) 4. 对于计算机的深入思考计算机终究只认识两个东西0、1,但是计算机要处理的是人类的输入并且最后要输出的东西也是要给人类使用的，这时候计算机要处理以下问题 接受人类输入的文字 把字符转化为自己能识别的0和1 对转化过的数据进行二进制之间的计算 对最终的计算结果进行编码成为用户可见的文字并呈现给使用者 其中把人类输入文字转换为0和1,和最终转换为用户可见的文字过程需要使用字符编码 解码:计算机识别的对应编码的二进制数字，按照编码格式转化为统一的编码格式，然后到编码表中找到对应的文字 编码：文字根据编码表找到对应的数值，然后转换为UNIQUE编码的二进制，在转换为工程对应的编码的二进制格式数据","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"一次读取配置文件的探究","slug":"2019/09/09/属性文件读取问题","date":"2019-09-09T17:51:03.000Z","updated":"2019-09-10T12:16:35.565Z","comments":true,"path":"2019/09/10/read_config/","link":"","permalink":"https://tonywang1.github.io/2019/09/10/read_config/","excerpt":"","text":"一次读取配置文件的探究 1. 问题的获取 用App.class.getResourceAsStream(fileName)找不到配置文件，然后去看了一遍源码，发现App.class.getClassLoader().getResourceAsStream代码是有区别的，整理如下： 2. class.getResourceAsStream(fileName)说明 相对路径：如果fileName不是用“/”开头的，则程序会找到Test这个类对应的目录去查找filename类 绝对路径：如果fileName用“/”开头的，则程序会直接从根目录查找对应的文件去加载 详细可以查看源码Class.java 中方法getResourceAsStream 12具体为Class 中的 getResourceAsStream中的方法可以查看详细：resolveName(name) 3.classLoader.getResourceAsStream() 是从类的根目录查找对应的文件，与当前的类路径无关 class中读取配置文件的方法也调用的这个方法 寻找资源文件的时候调用ClassLoader中方法getResource查找 具体查找文件方式为类加载器的双亲委托机制 4. ClassLoader查找文件规则双亲委托模型相关 从根类加载器关联的路径找对应的文件1根类加载器对应的文件路径：String bootClassPath = System.getProperty(&quot;sun.boot.class.path&quot;); 2 . 从扩展类加载器查找文件 1扩展类加载器对应路径：System.out.println(&quot;ext:&quot;+System.getProperty(&quot;java.ext.dirs&quot;)); 3 . 从应用类加载器-这部分包括我们自己项目的目录下所有的jar包和文件 1System.out.println(&quot;app:&quot;+System.getProperty(&quot;java.class.path&quot;)); 5. 那么三种加载器的属性文件在哪里设置的呢？ 所有系统属性可以通过下面的代码获取到，但是具体在什么地方设置的一直没有找到，留到以后探究吧。 1打印java所有的系统环境变量：java.util.Properties properties = System.getProperties();","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"Github上创建自己的网站","slug":"2019/08/30/Github创建网站","date":"2019-08-30T17:51:03.000Z","updated":"2019-11-18T12:53:26.415Z","comments":true,"path":"2019/08/31/gen_github_page/","link":"","permalink":"https://tonywang1.github.io/2019/08/31/gen_github_page/","excerpt":"","text":"Github搭建自己的博客 为什么要搭建自己的博客 探索未知世界 记录自己的成长 为后来者提供借鉴 梳理自己的逻辑思维 整理自己的学习知识，方便以后查阅 1. github page是什么？ GitHub页面是一种静态网站托管服务，旨在直接从GitHub存储库托管个人、组织或项目页面。 Github Page官方详细 2. hexo是什么？ 简单、快速、强大的Node.js静态博客框架 hexo源码 hexo官方网站 3. github page的设置 设置GitHubPage 个人操作借鉴 （详细请参考上文超链接） 创建一个repository，名称为（用户名 + .github.io ）括号中的以后是你博客的默认域名 切换tab到setting，并设置Repository name 4. nodejs、hexo安装，git安装nodejs的安装，直接百度就可以搜索到，直接下载安装非常简单git安装hexo安装参考 5. 创建、清理、发布、启动服务、本地访问文档地址 创建静态站点 hexo init 创建一个文章 hexo new [layout] &lt;title&gt; 生成静态文件 hexo generate 启动服务 hexo server 部署网站 hexo deploy 清除缓存和生成的静态文件 hexo clean 项目本地启动以后可以访问 http://localhost:4000/ 当我们写新的博客发布流程为我上面标号：2 、6、4、5 6. 步骤5中创建的项目与Git关联并上传到git仓库 git init git add . git commit &#39;评论&#39; 本地项目关联到git上：git remote add origin &lt;server&gt; 7. 更换主题 到 主题源码 页面fork源码到我们自己git上 主题安装 点击查看文档 修改配置文件（_config.yml）添加 theme: indigo指定主题 我用的indigo主题源码 8. hexo选择修改语言类型 现在项目还是英文的，需要修改项目的语言为中文 修改配置文件（_config.yml）中 language: zh-CN 6. hexo布局的使用 scaffolds文件夹中有3个文件分别为draft.md、page.md、post.md分别对应草稿、page格式、post格式的文件模板 命令 hexo new [layout] &lt;title&gt; 中的layout取值为：draft、page、post 三个文件中的Front-matter中可以放一些变量在里面，以便生成静态页面的时候可以使用 12345678这里是我自己搭建项目的模板 其中urlname这个变量设置以后生成的静态文件路径上会使用---title: &#123;&#123; title &#125;&#125;urlname: date: &#123;&#123; date &#125;&#125;tags:categories:--- 7. hexo生成静态页面的目录的设置配置文件_config.yml中设置下面的permalink参数，生成静态页面的访问路径，会根据Front-matter中的变量设置参数permalink: :year/:month/:day/:urlname/ 8. hexo标签和分类的使用，以及标签和分类区别分类生成及使用 打开命令行，进入博客所在文件夹。执行命令hexo new page categories 会生成一个文件 ，/categories/index.md 修改分类中的设置如下，有的版本使用type有的版本使用layout变量 1234567---title: 文章分类date: 2019-08-29 15:48:13comments: falsetype: categorieslayout: categories--- 写文章的收需要加上 categories: “文章标签名称” 原理：hexo 会找到layout: categories的设置，然后搜索所有文章中有categories设置的分类，生成分类列表 标签生成及使用操作： 打开命令行，进入博客所在文件夹。执行命令`hexo new page tags 下面的设置和categories一样了","categories":[{"name":"Github","slug":"Github","permalink":"https://tonywang1.github.io/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://tonywang1.github.io/tags/Github/"}]},{"title":"test1","slug":"test1","date":"2019-08-29T10:28:45.000Z","updated":"2019-08-29T02:28:45.788Z","comments":true,"path":"2019/08/29/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/29/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"test10","slug":"2019-8-29/test10","date":"2019-08-29T10:27:50.000Z","updated":"2019-08-30T06:28:44.938Z","comments":true,"path":"2019/08/29/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/29/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-28T07:50:32.729Z","updated":"2019-08-28T07:50:32.729Z","comments":true,"path":"2019/08/28/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/28/index/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}