{"meta":{"title":"雪地行人","subtitle":null,"description":"纷繁的大雪中驻立着的雪人","author":"Tony Wang","url":"https://tonywang1.github.io","root":"/"},"pages":[{"title":"test2","date":"2019-08-29T10:29:19.000Z","updated":"2019-08-29T02:29:19.551Z","comments":true,"path":"test2/index.html","permalink":"https://tonywang1.github.io/test2/index.html","excerpt":"","text":""},{"title":"文章标签分类","date":"2019-08-29T17:10:14.000Z","updated":"2019-08-30T02:34:03.665Z","comments":false,"path":"tags/index.html","permalink":"https://tonywang1.github.io/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-08-29T15:48:13.000Z","updated":"2019-08-30T02:34:26.785Z","comments":false,"path":"categories/index.html","permalink":"https://tonywang1.github.io/categories/index.html","excerpt":"","text":""},{"title":"test1","date":"2019-08-29T10:28:55.000Z","updated":"2019-08-29T02:28:55.505Z","comments":true,"path":"test1/index.html","permalink":"https://tonywang1.github.io/test1/index.html","excerpt":"","text":""}],"posts":[{"title":"MYSQL使用基础记录","slug":"2019/09/27/MYSQL使用基础记录","date":"2019-11-21T19:31:12.000Z","updated":"2019-11-21T12:04:40.083Z","comments":true,"path":"2019/11/22/mysql_basic/","link":"","permalink":"https://tonywang1.github.io/2019/11/22/mysql_basic/","excerpt":"","text":"#MYSQL使用基础记录 1.变量的定义 第一种用法：set @num=1; 或set @num:=1; //这里要使用变量来保存数据，直接使用@num变量 第二种用法：select @num:=1; 或 select @num:=字段名 from 表名 where …… 123实例如：1）set @t_error=0; select @t_error ;2）select @num:=`name` from sys_area where id=2 ; select @num; 2.启动事务和提交事务,回滚事务，如果打算启动事务则，设置自动提交为0，start transaction ; commit; 123456789 # 数值1自动提交 0手动提交select @@autocommit; #设置手动提交set @@autocommit=0;start transaction ; insert into dic(name ) values('1'); insert into dic(name ) values('2'); ROLLBACK;commit; 3.数据库的四个特性特性：原子性，一致性，隔离性，持久性.其中隔离性是不同事务之间的隔离原则，需要设置事务隔离级别来处理。 4.事务的隔离级别 1、 Read Uncommitted（读取未提交内容-未提交读） 2、 Read Committed（读取提交内容-提交读） 3、Repeatable Read（可重读） 4、 Serializable（可串行化） 123456781）查看当前会话隔离级别select @@tx_isolation;2）查看系统当前隔离级别select @@global.tx_isolation;3）设置当前会话隔离级别set session transaction isolatin level repeatable read;4）设置系统当前隔离级别set global transaction isolation level repeatable read; 5.数据库的共享锁和排它锁查询当前有多少事务，多少锁 12SELECT * FROM information_schema.INNODB_TRX ;SELECT * FROM information_schema.INNODB_LOCKS; 共享锁和排它锁不同点在于是否允许另一个事务读取被锁住的数据 共享锁锁住了一条id=1的数据，则其他的事务是可以读取，但不能更改 排它锁锁住了一条id=1的数据，其他的事务不可以读取，也不能更改，直到这个事务完成 如果另一个查询没有显示添加锁，则他是可以读取数据，不受上面锁影响 举个栗子： 1234567891011select @@autocommit; #设置手动提交set @@autocommit=0;set @t_error=0;select @t_error ;start transaction ; select * from dic for update ; insert into dic(name ) values('1'); insert into dic(name ) values('2'); ROLLBACK;commit; 6.外键删除外键不能直接删除，必须先删除外键然后删除相应的索引 1234567#查看表的外键以及外键名称show create table 表名#删除外键alter table 表名 drop FOREIGN KEY 外键名称 ;#显示所有的索引，并且删除需要删除的索引show index from 表名称 ;alter table 表名称 drop index FK_cv98jak9 ; 7.字段删除和添加12alter table 表名 drop column cluster_numalter table 表名 add cluster_num int comment &apos;数量&apos;; 8.NULL问题SELECT 1 = NULL, 1 &lt;&gt; NULL, 1 &lt; NULL, 1 &gt; NULL;9. 显示执行的进程show full processlist （状态字段的意思）或者（select * from information_schema.processlist where host like ‘%10.18.2.65%’） Sleep通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内（一般连接池会有一个参数initialSize，如果initialSize=10则初始化的时候会有10个状态为sleep连接被建立，并且一直存在），例如：数据查询时间为0.1秒，而网络输出需要1秒左右，原本数据连接在0.1秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在结果未展现在用户桌面前，该数据库连接一直维持在sleep状态 Locked操作被锁定，通常使用innodb可以很好的减少locked状态的产生 Copy to tmp table索引及现有结构无法涵盖查询条件时，会建立一个临时表来满足查询要求，产生巨大的i/o压力Copy to tmp table通常与连表查询有关，建议减少关联查询或者深入优化查询语句，如果出现此状态的语句执行时间过长，会严重影响其他操作，此时可以kill掉该操作 Sending dataSending data并不是发送数据，是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，如果sending data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化 Storing result to query cache如果频繁出现此状态，使用set profiling、“SHOW PROFILE” 分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query cache碎片较多，使用flush query cache可即时清理，Query cache参数可适当酌情设置 1 开启profiling功能：set profiling=1;2 显示所有记录的profile：show profiles;3 详细输出某个profile的记录：show profile cpu ,block io for query n(profile的id) 10.mysql日期时间函数的处理123456789101112131415date_format(date, format) 函数，MySQL日期格式化函数date_format()unix_timestamp( 时间日期) 函数 ，Mysql日期转换为unix时间戳str_to_date(str, format) 函数 ，字符串转化日期from_unixtime(unix_timestamp, format) 函数，MySQL时间戳格式化函数from_unixtime实例select DATE_FORMAT(now(),'%Y-%m-%d' ) select str_to_date('2017-12-08 00:00:00', '%Y-%m-%d %H:%i:%s' ) select unix_timestamp( DATE_FORMAT(now(),'%Y-%m-%d' ) )*1000 ;select unix_timestamp( str_to_date('2017-12-08 00:00:00', '%Y-%m-%d %H:%i:%s' ) )*1000 ;select from_unixtime( unix_timestamp( DATE_FORMAT(now(),'%Y-%m-%d' ) ),'%Y-%m-%d %H:%i:%s' ) ;数据库中的时间错：FROM_UNIXTIME(left(a.created_at,10), '%Y-%m-%d %H:%i:%S')&gt;'2018-01-01 00:00:00' select step_name,FROM_UNIXTIME(left(a.start_time,10), '%Y-%m-%d %H:%i:%S') 开始时间,FROM_UNIXTIME(left(a.end_time,10), '%Y-%m-%d %H:%i:%S') 结束时间from task_step1 a 11.多表关联更新与删除 关联更新一个表的数据123update user a join user_ext b on a.uid=b.id set b.name=a.name, b.age=a.agewhere ifNULL(a.business_ip,&apos;&apos;)&lt;&gt;ifNULL(b.new_business_ip,&apos;&apos;) 关联删除h表的数据123delete h.* from user g join user_ext h on g.id=h.userIdwhere g.id=1 12.in和exist的区别参照 13.数据导出和导入 备份：mysqldump 数据库名称 -u’用户名’ -p &gt; 表名称.sqlmysqldump -u 用户名 -p ‘密码’ –host=远程服务器地址 数据库名称 &gt; 数据库名称1.sql /usr/local/mysql/bin/mysqldump -q -h127.0.0.1 -udmin -p’密码’ -P3306 –single-transaction –databases 数据库名称 &gt; /data/tmp/备份数据库名_20111019.sql 导入：mysql&gt; source /tmp/表名称.sql 登陆：mysql -h mysql远程地址 -u 用户名 -p’密码’ 14.数据库的common内容显示乱码：修改编码格式123show variables like &apos;char%&apos;set character_set_connection=utf8 ;set character_set_results=utf8;","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://tonywang1.github.io/categories/MYSQL/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://tonywang1.github.io/tags/MYSQL/"},{"name":"SQL","slug":"SQL","permalink":"https://tonywang1.github.io/tags/SQL/"}]},{"title":"GRPC使用","slug":"2019/10/12/grpc","date":"2019-10-12T15:41:13.000Z","updated":"2019-11-18T10:00:29.536Z","comments":true,"path":"2019/10/12/you_know_grpc/","link":"","permalink":"https://tonywang1.github.io/2019/10/12/you_know_grpc/","excerpt":"","text":"GRPC初识 1.什么是GRPCGRPC是谷歌开源的高性能，跨语言的RPC框架，基于http2协议，交换描述语言为protobuf 2.GRPC描述与说明 GRPC的客户端可以直接调用服务端的方法，在任何的机器上，就像调用本地方法一样，因此利用GRPC可以更加方便的创建分布式的应用和服务。 GRPC需要定义一个服务，并说明服务的方法和返回值，然后Server方实现这个接口并运行GRPC服务去处理客户端的调用，客户端可以使用stub去调用服务端的接口（方法是一样的） 3.什么地方适合用GBPC 低延时、高可用的分布式系统； 移动端与云服务端的通讯； 使用protobuf，独立于语言的协议，支持多语言之间的通讯； 可以分层扩展，如：身份验证，负载均衡，日志记录，监控等。 服务端通信用的比较多 4.在java中如何使用GBPC 使用protobuf定义接口,即proto描述文件 使用maven的编译插件编译proto文件，生成对应的java文件 启动Server端，监听指定的端口 启动一个或者多个Client，去调用服务端暴露的接口 5.示例代码实例代码spring集成GRPC实例代码注意启动项目的时候需要修改spring-boot-starter-grpc对应的版本为对应模块的版本 6.主要参考 GRPC代码库 GRPC文档","categories":[{"name":"GRPC","slug":"GRPC","permalink":"https://tonywang1.github.io/categories/GRPC/"}],"tags":[{"name":"GRPC","slug":"GRPC","permalink":"https://tonywang1.github.io/tags/GRPC/"}]},{"title":"protobuf使用","slug":"2019/10/12/protobuf使用","date":"2019-10-12T15:41:13.000Z","updated":"2019-10-12T07:46:28.969Z","comments":true,"path":"2019/10/12/you_know_pb/","link":"","permalink":"https://tonywang1.github.io/2019/10/12/you_know_pb/","excerpt":"","text":"Protocol Buffer初识 1.什么是protobufgoogle开发的跨语言、跨平台、可扩展的可以序列化的数据结构，像XML一样，但是更小更快，更简单，你可以定义序列化的数据结构，然后用工具生成对应语言的源码，最后可以用各种语言对数据流结构进行读写。 2.protobuf优势在哪里 跨语言 跨平台 可扩展 小、快、简单 3.什么地方使用protobuf 数据压缩传输 数据压缩存储、持久化 4.在java中如何使用protobuf-maven插件可以直接生成java代码 创建proto目录，并在里面创建bookdress.proto文件-内容如代码4.1 maven的xml中添加protobuf文件生成源码的代码-内容如4.2 测试写入protobuf的代码4.3 测试读取protobuf的代码4.41234567891011121314151617181920212223代码4.1syntax = \"proto2\";package proto;option java_package = \"com.test.proto\";option java_outer_classname = \"AddressBookProtos\";message Person &#123; optional string name = 1; optional int32 id = 2; optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; optional string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phones = 4;&#125;message AddressBook &#123; repeated Person people = 1;&#125; 1234567891011121314151617181920212223242526272829303132333435363738代码4.2 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt; &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1.Final&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;protocArtifact&gt;com.google.protobuf:protoc:3.4.0:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 12345678910111213141516171819202122232425262728293031323334353637代码4.3package com.test;import com.test.proto.AddressBookProtos;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class WritePerson &#123; public static final String addr_book = \"addr_book.file\"; // 写入文件的名称 static AddressBookProtos.Person PromptForAddress(int index) throws IOException &#123; AddressBookProtos.Person.Builder person = AddressBookProtos.Person.newBuilder(); person.setId(index); person.setName(\"proto test \" + index); person.setEmail(\"a\"+index+\"@b.com\"); AddressBookProtos.Person.PhoneNumber.Builder phoneNumber = AddressBookProtos.Person.PhoneNumber.newBuilder().setNumber(\"110-\"+index); phoneNumber.setType(AddressBookProtos.Person.PhoneType.HOME); person.addPhones(phoneNumber); return person.build(); &#125; public static void main(String[] args) throws Exception &#123; AddressBookProtos.AddressBook.Builder addressBook = AddressBookProtos.AddressBook.newBuilder(); try &#123; addressBook.mergeFrom(new FileInputStream(addr_book)); &#125; catch (FileNotFoundException e) &#123; System.err.println( \" File not found. Creating a new file.\"); &#125; // 创建 address. addressBook.addPeople(PromptForAddress(1)); addressBook.addPeople(PromptForAddress(2)); addressBook.addPeople(PromptForAddress(3)); // 保存到文件 FileOutputStream output = new FileOutputStream(WritePerson.addr_book); addressBook.build().writeTo(output); output.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233代码4.4package com.test;import com.test.proto.AddressBookProtos;import java.io.FileInputStream;public class ReadPeople &#123; static void Print(AddressBookProtos.AddressBook addressBook) &#123; for (AddressBookProtos.Person person : addressBook.getPeopleList()) &#123; System.out.println(\"Person ID: \" + person.getId()); System.out.println(\" Name: \" + person.getName()); if (person.hasEmail()) &#123; System.out.println(\" E-mail address: \" + person.getEmail()); &#125; for (AddressBookProtos.Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123; switch (phoneNumber.getType()) &#123; case MOBILE: System.out.print(\" Mobile phone #: \"); break; case HOME: System.out.print(\" Home phone #: \"); break; case WORK: System.out.print(\" Work phone #: \"); break; &#125; System.out.println(phoneNumber.getNumber()); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; AddressBookProtos.AddressBook addressBook = AddressBookProtos.AddressBook.parseFrom(new FileInputStream(WritePerson.addr_book)); Print(addressBook); &#125;&#125; 5.主要参考 ProtoBuf的官方 ProtoBuf的maven集成插件 google开发者文档","categories":[{"name":"GRPC","slug":"GRPC","permalink":"https://tonywang1.github.io/categories/GRPC/"}],"tags":[{"name":"GRPC","slug":"GRPC","permalink":"https://tonywang1.github.io/tags/GRPC/"}]},{"title":"GO语言基础","slug":"2019/10/29/go-basic","date":"2019-10-12T15:41:13.000Z","updated":"2019-11-18T12:41:51.748Z","comments":true,"path":"2019/10/12/go_basic/","link":"","permalink":"https://tonywang1.github.io/2019/10/12/go_basic/","excerpt":"","text":"#GO语言简介个人从学习从入手不到一周基本可以开始开发：1 go语法基础看了一遍2 经常用到的难点突破一下3 beego网路开发官方文档主要的部分看一遍 1.什么是GO语言Go（又称 Golang）是 Google 开源的一种静态强类型、编译型语言 2.什么要用GO语言 简单高效 开发速度快 容易开发并行性代码 部署简单 3.GO如何安装 下载go-https://golang.org/dl/ 安装并设置go的环境变量-go的bin目录添加的环境变量path中 ，C:\\Go\\bin 执行go version ，打印go的版本，安装完成 go evn，打印go的所有相关变量 4.基础语法记录基础语法学习参考 1) 指针、对象、值传递和引用传递 go普通变量:变量直接指向存在内存中的值 go指针变量**:变量指向值存储的地址，实际的内存地址 new(T) 返回 T 的指针 *T， 并指向 T 的零值。– 指针 make(T) 返回的初始化的 T的引用，只能用于 slice，map，channel。 - 引用 City{Id: id} == 返回对象引用 new(City) == 返回对象指针 函数的参数两种：值传递（数值的拷贝）、引用传递（指针） 2) 类型转换 strconv - 字符串和各种数据类型的转换 整数之间转换 整数之间强转：int := int(int32) 整数转为字符串：strconv.Itoa( ) boolean转为字符串：strconv.FormatBool(isDebug) 字节与字符串的转换： var a = []byte(“hello boy”) var b = string(a) strings:字符串的工具类 3) 命名规范 golang的命名推荐使用驼峰命名法，必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线 golang中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用可以简单的理解成，首字母大写是公有的，首字母小写是私有的 结构体中属性名的大写-小写的json不能解析 4) json使用 类型断言:interface.(int) 反序列化，指定对应的struct，只有key的第一个字母大写才能被反序列化 序列化key必须是字符串，值为指针，则序列化为对应的值 5) simplejson使用 simplejson：解析复杂json，解析时候最好从根部解析。 参照：https://blog.csdn.net/chenghuan1990/article/details/75423325 6) struct tags修改json序列化和反序列化的对应 改变对应序列化和反序列化后的名称 指定空值得处理 是否忽略某个字段 类型判断：switch vv := v.(type) 7)io.Reader/Writer常用 字节缓冲区，字节、字符串、Reader之间的操作 net.Conn, os.Stdin, os.File: 网络、标准输入输出、文件的流读取 strings.Reader: 把字符串抽象成Reader bytes.Reader: 把[]byte抽象成Reader bytes.Buffer: 把[]byte抽象成Reader和Writer bufio.Reader/Writer: 抽象成带缓冲的流读取（比如按行读写） 8) http使用 restclient: https://github.com/ylywyn/restclient 标准库：http 5.IDEA中开发GO项目 1 设置GOROOT-项目相关的包都是从这个目录开始查找的 2 设置GOPATH-添加gopath到设置中 3 Setting的设置GoModule ，允许go module集成 ，设置Proxy=https://goproxy.cn 4 生成依赖管理文件go.mod: go mod init – 项目使用modules管理，并生成管理文件go.mod每次build会将项目中的包信息，放到这个文件中go mod download – 会将项目依赖包放到go安装目录的pkg目录中，所有项目共享go.mod文件：为项目的依赖包，描述项目的名称和依赖的第三方的包go.sum文件：为项目的依赖分析文件，记录每个依赖库的版本和哈希值 5 将依赖包生成到本地: go mod vendor - 将依赖包放到项目中的vendor目录中，本项目独有，idea就可以识别了 6 启动项目 ： bee run -gendoc=true -downdoc=true 注意： 1 项目要用go的module形式进行管理 go mod init 2 项目中引入的所有包进入到包管理文件： go build（会将包信息写到go.mod中） 3 下载对应的包到项目的vendor目录中：go mod vendor 6.主要参考 1) https://www.runoob.com/go/go-tutorial.html 2) beego官网 3）go官网","categories":[{"name":"GO","slug":"GO","permalink":"https://tonywang1.github.io/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"https://tonywang1.github.io/tags/GO/"}]},{"title":"RESOURCE插件说明","slug":"2019/09/17/MAVEN-resource插件","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-24T08:20:15.479Z","comments":true,"path":"2019/09/18/maven_plugin_resource/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/maven_plugin_resource/","excerpt":"","text":"#RESOURCE插件说明 ##1插件说明 官方说明 resources:resources标签全名为org.apache.maven.plugins:maven-resources-plugin:3.1.0:resources即plugin中配置的资源的插件和resource标签的是同样的东西 资源插件会拷贝对应的资源根据resource标签的设置 ##2插件种类Resources插件目标有三个，主要的不同点在于：拷贝资源中的一些默认值和文件的输出目录不同 resources:resources:拷贝main resources到main output directory,它绑定了process-resources生命周期阶段，当执行Compiler:compile插件目标前就会自动执行此阶段。 resources:testResources：拷贝test resources到test output directory，它绑定了process-test-resources生命周期阶段，当执行surefire:test插件目标前就会执行此阶段 resources:copy-resources：需要自己手动配置去拷贝文件，拷贝资源去输出目录。 ##3为什么要有resource插件项目中文件通常有两种： 1 需要编译的java文件 2 不需要编译的资源文件 这两种文件通过不同的插件分别处理，其中第二种资源文件就是需要resource插件处理 ##4resource插件能解决什么问题？ 资源文件拷贝目录的设置 - 代码4.2 插件读取配置的编码情况 - 代码4.1 过滤器的设置 - 代码4.3 精确控制资源拷贝- 代码4.4 排除过滤 - 代码4.5 copy-resources 主目录中某些资源的拷贝 - 代码4.6 123456789101112代码4.1&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1234567891011代码4.2&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources1&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources2&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 123456789101112代码4.3&lt;build&gt; &lt;filters&gt; &lt;filter&gt;filter-values.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 12345678910111213141516代码4.4 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.txt&lt;/include&gt; &lt;include&gt;**/*.rtf&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.bmp&lt;/exclude&gt; &lt;exclude&gt;**/*.jpg&lt;/exclude&gt; &lt;exclude&gt;**/*.jpeg&lt;/exclude&gt; &lt;exclude&gt;**/*.gif&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resources&gt; 123456789101112131415代码4.5&lt;!-- 过滤后缀为pdf和swf的文件 --&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;nonFilteredFileExtensions&gt; &lt;nonFilteredFileExtension&gt;pdf&lt;/nonFilteredFileExtension&gt; &lt;nonFilteredFileExtension&gt;swf&lt;/nonFilteredFileExtension&gt; &lt;/nonFilteredFileExtensions&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;plugins&gt; 123456789101112131415161718192021222324代码4.6 &lt;!-- 资源目录 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，只处理如下配置中包含的资源类型 --&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，不处理如下配置中包含的资源类型（剔除下如下配置中包含的资源类型）--&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.yaml&lt;/exclude&gt; &lt;/excludes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，指定处理后的资源文件输出目录，默认是$&#123;build.outputDirectory&#125;指定的目录--&gt; &lt;!--&lt;targetPath&gt;$&#123;build.outputDirectory&#125;&lt;/targetPath&gt; --&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，是否对主资源目录开启资源过滤 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;","categories":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/categories/MAVEN/"}],"tags":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/tags/MAVEN/"}]},{"title":"JAVA时间总结","slug":"2019/09/24/JAVA日期时间","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-24T09:55:00.401Z","comments":true,"path":"2019/09/18/java_date/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/java_date/","excerpt":"","text":"JAVA时间总结 1.UTC(世界标准时间)什么是utc时间 即协调世界时。UTC是以原子时秒长为基础，在时刻上尽量接近于GMT的一种时间计量系统。为确保UTC与GMT相差不会超过0.9秒，在有需要的情况下会在UTC内加上正或负闰秒。UTC现在作为世界标准时间使用 2.GMT(格林尼治平时) 即格林尼治标准时间，也就是世界时。GMT的正午是指当太阳横穿格林尼治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致GMT不精确，现在已经不再作为世界标准时间使用。 UTC和GMT时间误差不超过0.9秒,即两者基本相同 3.CST(北京时间) 北京时间，China Standard Time，中国标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8 java日期工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544public class DateUtils &#123; private static final SimpleDateFormat datetimeFormat = new SimpleDateFormat( \"yyyy-MM-dd HH:mm:ss\"); private static final SimpleDateFormat dateFormat = new SimpleDateFormat( \"yyyy-MM-dd\"); private static final SimpleDateFormat timeFormat = new SimpleDateFormat( \"HH:mm:ss\"); /** * 获得当前日期时间 * &lt;p&gt; * 日期时间格式yyyy-MM-dd HH:mm:ss * * @return */ public static String currentDatetime() &#123; return datetimeFormat.format(now()); &#125; /** * 格式化日期时间 * &lt;p&gt; * 日期时间格式yyyy-MM-dd HH:mm:ss * * @return */ public static String formatDatetime(Date date) &#123; return datetimeFormat.format(date); &#125; /** * 格式化日期时间 * * @param date * @param pattern * 格式化模式，详见&#123;@link SimpleDateFormat&#125;构造器 * &lt;code&gt;SimpleDateFormat(String pattern)&lt;/code&gt; * @return */ public static String formatDatetime(Date date, String pattern) &#123; SimpleDateFormat customFormat = (SimpleDateFormat) datetimeFormat .clone(); customFormat.applyPattern(pattern); return customFormat.format(date); &#125; /** * 格式化 时间戳 * @param date * @param pattern * @return */ public static String formatDatetime(Timestamp date, String pattern) &#123; SimpleDateFormat customFormat = (SimpleDateFormat) datetimeFormat .clone(); customFormat.applyPattern(pattern); return customFormat.format(date); &#125; /** * 字符串日期 格式化后 变为字符串形式 * @param date * @param pattern * @return */ public static String formatDatetime(String date, String pattern) &#123; Date date2 = null; try &#123; SimpleDateFormat customFormat = (SimpleDateFormat) datetimeFormat .clone(); customFormat.applyPattern(pattern); date2 = customFormat.parse(date ); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return formatDatetime(date2, pattern); &#125; /** * * @param * @return */ public static long getCurTimestamp(Date date)&#123; String curDate = formatDatetime( date, \"yyyyMMddHHmmss\" ) ; return Long.parseLong( curDate) ; &#125; /** * 字符串转换成日期 * @param * @return pattern 日期格式 \"yyyy-MM-dd HH:mm:ss\" */ public static Date strToDate(String dateStr,String pattern) &#123; SimpleDateFormat format = new SimpleDateFormat(pattern); Date date = null; try &#123; date = format.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; /** * 获得当前日期 * &lt;p&gt; * 日期格式yyyy-MM-dd * * @return */ public static String currentDate() &#123; return dateFormat.format(now()); &#125; /** * 格式化日期 * &lt;p&gt; * 日期格式yyyy-MM-dd * * @return */ public static String formatDate(Date date) &#123; return dateFormat.format(date); &#125; /** * 获得当前时间 * &lt;p&gt; * 时间格式HH:mm:ss * * @return */ public static String currentTime() &#123; return timeFormat.format(now()); &#125; /** * 格式化时间 * &lt;p&gt; * 时间格式HH:mm:ss * * @return */ public static String formatTime(Date date) &#123; return timeFormat.format(date); &#125; /** * 获得当前时间的&lt;code&gt;java.util.Date&lt;/code&gt;对象 * * @return */ public static Date now() &#123; return new Date(); &#125; public static Calendar calendar() &#123; Calendar cal = GregorianCalendar.getInstance(Locale.CHINESE); cal.setFirstDayOfWeek(Calendar.MONDAY); return cal; &#125; /** * 获得当前时间的毫秒数 * &lt;p&gt; * 详见&#123;@link System#currentTimeMillis()&#125; * * @return */ public static long millis() &#123; return System.currentTimeMillis(); &#125; /** * * 获得当前Chinese月份 * * @return */ public static int month() &#123; return calendar().get(Calendar.MONTH) + 1; &#125; /** * 获得月份中的第几天 * * @return */ public static int dayOfMonth() &#123; return calendar().get(Calendar.DAY_OF_MONTH); &#125; /** * 今天是星期的第几天 * * @return */ public static int dayOfWeek() &#123; return calendar().get(Calendar.DAY_OF_WEEK); &#125; /** * 今天是年中的第几天 * * @return */ public static int dayOfYear() &#123; return calendar().get(Calendar.DAY_OF_YEAR); &#125; /** *判断原日期是否在目标日期之前 * * @param src * @param dst * @return */ public static boolean isBefore(Date src, Date dst) &#123; return src.before(dst); &#125; /** *判断原日期是否在目标日期之后 * * @param src * @param dst * @return */ public static boolean isAfter(Date src, Date dst) &#123; return src.after(dst); &#125; /** *判断两日期是否相同 * * @param date1 * @param date2 * @return */ public static boolean isEqual(Date date1, Date date2) &#123; return date1.compareTo(date2) == 0; &#125; /** * 判断某个日期是否在某个日期范围 * * @param beginDate * 日期范围开始 * @param endDate * 日期范围结束 * @param src * 需要判断的日期 * @return */ public static boolean between(Date beginDate, Date endDate, Date src) &#123; return beginDate.before(src) &amp;&amp; endDate.after(src); &#125; /** * 获得当前月的最后一天 * &lt;p&gt; * HH:mm:ss为0，毫秒为999 * * @return */ public static Date lastDayOfMonth() &#123; Calendar cal = calendar(); cal.set(Calendar.DAY_OF_MONTH, 0); // M月置零 cal.set(Calendar.HOUR_OF_DAY, 0);// H置零 cal.set(Calendar.MINUTE, 0);// m置零 cal.set(Calendar.SECOND, 0);// s置零 cal.set(Calendar.MILLISECOND, 0);// S置零 cal.set(Calendar.MONTH, cal.get(Calendar.MONTH) + 1);// 月份+1 cal.set(Calendar.MILLISECOND, -1);// 毫秒-1 return cal.getTime(); &#125; /** * 获得当前月的第一天 * &lt;p&gt; * HH:mm:ss SS为零 * * @return */ public static Date firstDayOfMonth() &#123; Calendar cal = calendar(); cal.set(Calendar.DAY_OF_MONTH, 1); // M月置1 cal.set(Calendar.HOUR_OF_DAY, 0);// H置零 cal.set(Calendar.MINUTE, 0);// m置零 cal.set(Calendar.SECOND, 0);// s置零 cal.set(Calendar.MILLISECOND, 0);// S置零 return cal.getTime(); &#125; private static Date weekDay(int week) &#123; Calendar cal = calendar(); cal.set(Calendar.DAY_OF_WEEK, week); return cal.getTime(); &#125; /** * 获得周五日期 * &lt;p&gt; * 注：日历工厂方法&#123;@link #calendar()&#125;设置类每个星期的第一天为Monday，US等每星期第一天为sunday * * @return */ public static Date friday() &#123; return weekDay(Calendar.FRIDAY); &#125; /** * 获得周六日期 * &lt;p&gt; * 注：日历工厂方法&#123;@link #calendar()&#125;设置类每个星期的第一天为Monday，US等每星期第一天为sunday * * @return */ public static Date saturday() &#123; return weekDay(Calendar.SATURDAY); &#125; /** * 获得周日日期 * &lt;p&gt; * 注：日历工厂方法&#123;@link #calendar()&#125;设置类每个星期的第一天为Monday，US等每星期第一天为sunday * * @return */ public static Date sunday() &#123; return weekDay(Calendar.SUNDAY); &#125; /** * 将字符串日期时间转换成java.util.Date类型 * &lt;p&gt; * 日期时间格式yyyy-MM-dd HH:mm:ss * * @param datetime * @return */ public static Date parseDatetime(String datetime) throws ParseException &#123; return datetimeFormat.parse(datetime); &#125; /** * 将字符串日期转换成java.util.Date类型 *&lt;p&gt; * 日期时间格式yyyy-MM-dd * * @param date * @return * @throws ParseException */ public static Date parseDate(String date) throws ParseException &#123; return dateFormat.parse(date); &#125; /** * 将字符串日期转换成java.util.Date类型 *&lt;p&gt; * 时间格式 HH:mm:ss * * @param time * @return * @throws ParseException */ public static Date parseTime(String time) throws ParseException &#123; return timeFormat.parse(time); &#125; /** * 根据自定义pattern将字符串日期转换成java.util.Date类型 * * @param datetime * @param pattern * @return * @throws ParseException */ public static Date parseDatetime(String datetime, String pattern) throws ParseException &#123; SimpleDateFormat format = (SimpleDateFormat) datetimeFormat.clone(); format.applyPattern(pattern); return format.parse(datetime); &#125; //北京时间转为utc时间，oozie 使用 public static String BJ2UTC(String time) &#123; Date date = null; try &#123; date = parseDatetime(time); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; Calendar cal = Calendar.getInstance( ); cal.setTime(date);//date 换成已经已知的Date对象 cal.add(Calendar.HOUR_OF_DAY, -8);// before 8 hour SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\"); return sdf.format(cal.getTime( )); &#125; /* * 将时间戳转换为时间 */ public static String stampToDate(Long timestamp)&#123; Date date = new Date(timestamp); return formatDatetime(date) ; &#125; /** * 得到最近一个月的所有日期 * @param d 传入的日期 * @return */ public static List&lt;String&gt; getDaysMonthByDate(Date d,String pattern)//根据传入的日期获取一个月内的所有日期 &#123; List&lt;String&gt; lst=new ArrayList&lt;String&gt;(); Date startDate = getOneMonthDate(d); while (!startDate.after(d)) &#123; lst.add(formatDatetime(startDate,pattern)); startDate = getNext(startDate); &#125; return lst; &#125; /** * 得到一个月前的日期 * @param d * @return */ private static Date getOneMonthDate(Date d )&#123; Calendar calendar = Calendar.getInstance(); calendar.setTime( d ); calendar.add( Calendar.MONTH, -1 ); calendar.add( Calendar.DAY_OF_MONTH, 1); return calendar.getTime(); &#125; /** * 当前日期+1天 * @param date * @return */ public static Date getNext(Date date) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(Calendar.DATE, 1); return calendar.getTime(); &#125; /** * * @param datetime 2017-10-01T16:00:00.000Z * @param format yyyy-MM-dd'T'HH:mm:ss.SSS'Z' * @return */ //utc 转换为 北京时间 （时间带有T分隔符的） public static Date UTC2BJ(String datetime, String format) &#123; SimpleDateFormat customFormat = (SimpleDateFormat) datetimeFormat.clone(); customFormat.applyPattern(format); customFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\") ); Date date = null; try &#123; date = customFormat.parse( datetime); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; /** * UTC 时间转化为bj时间的字符串 * @param datetime * @param format * @return */ public static String UTC2BJStr(String datetime, String format)&#123; Date date = UTC2BJ(datetime,format); return formatDatetime( date ); &#125; /** * 获取某一天的开始时间 * @param date * @return */ public static Date getDayBegin(Date date) &#123; Calendar cal = new GregorianCalendar(); cal.setTime(date); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); &#125; /** * 获取当天的结束时间 * @param date * @return */ public static Date getDayEnd(Date date) &#123; Calendar cal = new GregorianCalendar(); cal.setTime(date); cal.set(Calendar.HOUR_OF_DAY, 23); cal.set(Calendar.MINUTE, 59); cal.set(Calendar.SECOND, 59); return cal.getTime(); &#125; public static void main(String[] args) &#123;// String str = formatDatetime(\"1984-1-1 12:12:13\",\"yyyy-MM-dd\");// System.out.println(str );// Long t = millis(); String startCreateDate=\"2017-10-01T16:00:00.000Z\"; Date start = DateUtils.UTC2BJ( startCreateDate, \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\" ); System.out.println( start);// Long t = 1504681347375l;// String str = stampToDate(t );// System.out.println(t+\"===\"+ str );// // List list = getDaysMonthByDate(new Date(),\"M月d\");// for(int i=0;i&lt;list.size();i++ )&#123;// System.out.println( list.get(i));// &#125; // String str2 = BJ2UTC( \"2099-12-12 12:12:12\") ;// System.out.print(str2 ); &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"},{"name":"DATE","slug":"DATE","permalink":"https://tonywang1.github.io/tags/DATE/"}]},{"title":"MAVEN插件总览","slug":"2019/09/17/MAVEN插件","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-24T08:20:50.663Z","comments":true,"path":"2019/09/18/maven_plugin/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/maven_plugin/","excerpt":"","text":"maven插件知识总览 1.对于maven插件的了解插件官网： http://maven.apache.org/plugins/index.html Maven 本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成。如编译源代码是由 maven-compiler-plugin完成的，每个任务阶段对应了一个插件目标（goal），每个插件会有一个或者多个目标，如maven- compiler-plugin的compile目标用来编译位于src/main/java/目录下的主源码，testCompile目标用来编译位于src/test/java/目录下的测试源码 2.常用插件1） maven-antrun-pluginhttp://maven.apache.org/plugins/maven-antrun-plugin/ 2） maven-archetype-pluginhttp://maven.apache.org/archetype/maven-archetype-plugin/ 3） maven-assembly-pluginhttp://maven.apache.org/plugins/maven-antrun-plugin/ 4） maven-dependency-pluginhttp://maven.apache.org/plugins/maven-dependency-plugin/ maven-dependency-plugin最大的用途是帮助分析项目依赖，dependency:list能够列出项目最终解析到的依赖列表，dependency:tree能进一步的描绘项目依赖树，dependency:analyze可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin还有很多目标帮助你操作依赖文件，例如dependency:copy-dependencies能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面。 5）maven-help-plugin官网插件地址：http://maven.apache.org/plugins/maven-help-plugin/ maven-help-plugin是一个小巧的辅助工具，最简单的help:system可以打印所有可用的环境变量和Java系统属性。help:effective-pom和help:effective-settings最 为有用，它们分别打印项目的有效POM和有效settings，有效POM是指合并了所有父POM（包括Super POM）后的XML，当你不确定POM的某些信息从何而来时，就可以查看有效POM。有效settings同理，特别是当你发现自己配置的 settings.xml没有生效时，就可以用help:effective-settings来验证。此外，maven-help-plugin的describe目标可以帮助你描述任何一个Maven插件的信息，还有all-profiles目标和active-profiles目标帮助查看项目的Profile。 6）maven-resources-plugin 官网插件地址：http://maven.apache.org/plugins/maven-resources-plugin 作用：为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。此外，资源文件过滤也是Maven的一大特性，你可以在资源文件中使用${propertyName}形式的Maven属性，然后配置maven-resources-plugin开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者Profile传入属性的值，以实现更为灵活的构建。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546代码6.1 设置资源文件编码&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!--配置资源文件编码--&gt; &lt;/configuration&gt;&lt;/plugin&gt;``` ### 7）versions-maven-plugin 官网插件地址：[http://mojo.codehaus.org/versions-maven-plugin/](http://mojo.codehaus.org/versions-maven-plugin/) 很多Maven用户遇到过这样一个问题，当项目包含大量模块的时候，为他们集体更新版本就变成一件烦人的事情，到底有没有自动化工具能帮助完成这件 事情呢？（当然你可以使用sed之类的文本操作工具，不过不在本文讨论范围）答案是肯定的，versions-maven- plugin提供了很多目标帮助你管理Maven项目的各种版本信息。例如最常用的，命令 mvn versions:set -DnewVersion=1.1-SNAPSHOT 就能帮助你把所有模块的版本更新到1.1-SNAPSHOT。该插件还提供了其他一些很有用的目标，display-dependency- updates能告诉你项目依赖有哪些可用的更新；类似的display-plugin-updates能告诉你可用的插件更新；然后use- latest-versions能自动帮你将所有依赖升级到最新版本。最后，如果你对所做的更改满意，则可以使用 mvn versions:commit 提交，不满意的话也可以使用 mvn versions:revert 进行撤销。## 8 war包相关的例子-执行打war阶段的时候自动执行- 官网地址：[https://maven.apache.org/plugins/maven-war-plugin](https://maven.apache.org/plugins/maven-war-plugin/)- 所有的路径都是相对于pom文件的路径 &lt;!-- maven-war-plugin：mvn install可以将项目打成war包 --&gt;```xml&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;&lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;!-- 需要打包的目标文件路径 --&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt;&lt;!-- 指定build资源具体目录，默认是base directory。 --&gt; &lt;targetPath&gt;WEB-INF&lt;/targetPath&gt; &lt;!-- 打包的文件叫什么 --&gt; &lt;includes&gt; &lt;include&gt;**/web.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;!-- 打包后放在这个目录下 --&gt;&lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt; &lt;webXml&gt;src/main/webapp/WEB-INF/web.xml&lt;/webXml&gt;&lt;/configuration&gt;&lt;/plugin&gt; 123456789101112131415 说明：指定打包的目录和对应的web.xml文件&lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt;&lt;/plugin&gt; 9 编译插件使用实例-执行编译阶段的时候会自动执行 官网地址:https://maven.apache.org/plugins/maven-compiler-plugin/ 使用实例：12345678910111213141516 &lt;plugin&gt; &lt;!-- 指定maven编译的jdk版本,如果不指定,maven3默认用jdk 1.5 maven2默认用jdk1.3 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- 一般而言，target与source是保持一致的，但是，有时候为了让程序能在其他版本的jdk中运行(对于低版本目标jdk，源代码中不能使用低版本jdk中不支持的语法)，会存在target不同于source的情况 --&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!-- 源代码使用的JDK版本 --&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt;&lt;!-- 字符集编码 --&gt; &lt;skipTests&gt;true&lt;/skipTests&gt;&lt;!-- 跳过测试 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; 10 spring打可执行的插件 官网地址:https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html spring打包实例12345678&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;主类&lt;/mainClass&gt; &lt;/configuration&gt;&lt;/plugin&gt;","categories":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/categories/MAVEN/"}],"tags":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/tags/MAVEN/"}]},{"title":"mysql-sql执行流程","slug":"2019/09/27/MYSQL-SQL执行流程","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-27T09:14:20.979Z","comments":true,"path":"2019/09/18/linux_cron/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/linux_cron/","excerpt":"","text":"MYSQL-SQL执行流程 1.SQL的执行流程 词法分析-&gt;语法分析-解析树-预处理-检查权限-新解析树-查询优化器-执行计划-存储引擎获取数据 1.SQL 的关键字执行的流程如何 1）执行的SQL语句-每一步执行的输出，是下一步的输入 1234567891011121314 SELECT DISTINCT &lt; select_list &gt;FROM &lt; left_table &gt; &lt; join_type &gt;JOIN &lt; right_table &gt; ON &lt; join_condition &gt;WHERE &lt; where_condition &gt;GROUP BY &lt; group_by_list &gt;HAVING &lt; having_condition &gt;ORDER BY &lt; order_by_condition &gt;LIMIT &lt; limit_number &gt; 2)实际执行流程 12345678910FROM &lt;left_table&gt;ON &lt;join_condition&gt;&lt;join_type&gt; JOIN &lt;right_table&gt;WHERE &lt;where_condition&gt;GROUP BY &lt;group_by_list&gt;HAVING &lt;having_condition&gt;SELECT DISTINCT &lt;select_list&gt;ORDER BY &lt;order_by_condition&gt;LIMIT &lt;limit_number&gt; 3 执行顺序实例1）准备工作 123456789101112131415161718CREATE DATABASE /*!32312 IF NOT EXISTS*/`test1db` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `test1db`;CREATE TABLE `table1` ( `uid` varchar(10) NOT NULL, `name` varchar(10) NOT NULL, PRIMARY KEY (`uid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `table1`(`uid`,`name`) values (&apos;aaa&apos;,&apos;mike&apos;),(&apos;bbb&apos;,&apos;jack&apos;),(&apos;ccc&apos;,&apos;mike&apos;),(&apos;ddd&apos;,&apos;mike&apos;);CREATE TABLE `table2` ( `oid` int(11) NOT NULL AUTO_INCREMENT, `uid` varchar(10) DEFAULT NULL, `old` int(11) DEFAULT NULL COMMENT &apos;年龄&apos;, PRIMARY KEY (`oid`)) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;insert into `table2`(`oid`,`uid`,`old`) values (1,&apos;aaa&apos;,2),(2,&apos;aaa&apos;,1),(3,&apos;bbb&apos;,3),(4,&apos;bbb&apos;,4),(5,&apos;bbb&apos;,5),(6,&apos;ccc&apos;,6),(7,NULL,7); 2）最终的执行结果 123456789101112131415SELECT a.uid, count(b.oid) AS total FROM table1 AS aLEFT JOIN table2 AS b ON a.uid = b.uidWHERE a. NAME = &apos;mike&apos;GROUP BY a.uidHAVING count(b.oid) &lt; 2ORDER BY total DESCLIMIT 1; 3）执行FROM关键字-笛卡尔积 123select * from table1 a left join table2 b on a.uid=b.uid 4) ON关键字过滤-v-4 1select * from table1 a join table2 b on a.uid=b.uid ; 5)如果使用了外连接(LEFT,RIGHT,FULL)，主表（保留表）中的不符合ON条件的列也会被加入到这一步的执行结果中-生成新的虚拟表v-5 6）WHERE条件过滤 -v-6对于上面的执行结果，满足WHERE条件的结果集的数据，会生成新的虚拟表 v-6 1234select * from table1 a left join table2 b on a.uid=b.uid where a.name=&apos;mike&apos; 注意：ON和where条件过滤的区别 1 在inner join的时候 ，两者查询的结果一样2 在外连接(LEFT,RIGHT,FULL)查询的时候，on对关联表进行条件过滤，然后在与主表进行关联，这个过程中这个查询条件对主表不会有影响3 在外连接(LEFT,RIGHT,FULL)查询的时候，where 条件过滤，是对连接后的整个临时表进行过滤，不分主从 123查询示例：select * from table1 a left join table2 b on a.uid=b.uid and b.oid='1' ; select * from table1 a left join table2 b on a.uid=b.uid where b.oid='1' ; 总结 主表进行过滤必须放到WHERE条件后，从表过滤如果先过滤后链接则条件放到on后面，如果先链接在过滤则放到WHERE条件后 7）GROUP BY 关键字进行过滤 这个会对表 v-6中的表的某些字段进行分组，他对于后面的SELECT,和HAVING所用到的列必须包含在GROUP BY 中，对于没有出现的必须进行聚合运算 对于mysql上面的限制条件可以忽略，但是select字段中没有出现在group by中的字段，会随机选择一个值。 8)HAVING 关键字作用：对分组后的数据进行过滤，满足条件的数据放到下一个虚拟表中-v-8 123456789101112SELECT a.uid, count(b.oid) AS total FROM table1 AS aLEFT JOIN table2 AS b ON a.uid = b.uidWHERE a. NAME = 'mike'GROUP BY a.uidHAVING count(b.oid) &lt; 1 9)SELECT 对select子句进行处理1 - 计算select子句的表达式2 - 如果有 DISTINCT，则进行去重 10）ORDER BY-根据ORDER BY 子句的条件对结果进行排序唯一可使用SELECT中别名的地方 1234567891011121314SELECT a.uid, count(b.oid) AS total FROM table1 AS aLEFT JOIN table2 AS b ON a.uid = b.uidWHERE a. NAME = &apos;mike&apos;GROUP BY a.uidHAVING count(b.oid) &lt; 1ORDER BY total DESC 11) LIMIT-子句从上一步得到的虚拟表中选出从指定位置开始的指定行数据 2 SQL中关联表on后面的条件与where后面条件有什么不同详细见上面的6 ##3.同一个字段不同值的统计处理查询一个用户有多少条年龄数据： 12345select name, sum(case when (old is not null) then 1 else 0 end ) &apos;个数&apos;from table1 a left join table2 b on a.uid=b.uid group by a.name ;","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://tonywang1.github.io/categories/MYSQL/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://tonywang1.github.io/tags/MYSQL/"},{"name":"SQL","slug":"SQL","permalink":"https://tonywang1.github.io/tags/SQL/"}]},{"title":"CURL使用","slug":"2019/09/24/CURL命令记录","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-25T03:18:29.977Z","comments":true,"path":"2019/09/18/linux_curl/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/linux_curl/","excerpt":"","text":"CURL使用 1.curl作用 curl是一个利用URL规则在命令行下工作的文件传输工具 2语法 curl [option] [url] 3实例 发送get、post请求-代码3.1 发送带有参数的get和post请求 - 3.2 查看请求的整个请求链路-调试谁用 - 3.3 发送带有header请求 - 4.4 发送设置host的请求 -4.4 12代码3.1curl -i(返回头信息) -X POST/Get http//www.baidu.com 12345代码3.2- 发送applicationjson数据- curl -H &quot;Content-Type:application/json&quot; -X POST -d &apos;&#123;&quot;user&quot;: &quot;admin&quot;, &quot;passwd&quot;:&quot;12345678&quot;&#125;&apos; https://proxy.mimvp1.com/login- 普通数据提交- curl -d &quot;param1=value1&amp;param2=value2&quot; -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -X POST http://localhost:3001/data 12代码3.3curl -X POST/Get http//www.baidu.com -xvo /usr/null 12代码4.4curl &apos;http://localhost/hadoop1/clusters/list?page=1&amp;pageSize=50&amp;total=0&amp;tokenId=tokenId_a218_4ab8_8404_3ac9a4b63d2c&apos; -H &apos;host:bd1prod.localhost.com","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/categories/LINUX/"}],"tags":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/tags/LINUX/"},{"name":"CURL","slug":"CURL","permalink":"https://tonywang1.github.io/tags/CURL/"}]},{"title":"maven浅尝辄止1","slug":"2019/09/17/maven浅尝辄止","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-24T08:21:41.628Z","comments":true,"path":"2019/09/18/maven1/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/maven1/","excerpt":"","text":"maven的认识 1.什么是maven？ Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。参考 2. maven能帮我们解决什么问题 项目统一构建 - 统一生成项目结构 jar包统一管理 - 自动下载jar包、对应的jar包的依赖、jar包不同版本冲突问题、jar包版本统一管理 项目版本统一管理 - Release和SNAPSHOT版本即稳定版本和快照版本 项目的编译、测试、打包 、安装、发布等管理 项目不同环境配置的管理 不同项目之间依赖管理 3. maven中如何使用profile来解决项目不同环境的问题profile使用原理：通过激活某个profile来加载对应的属性，达到不同环境加载不同属性作用 1、命令激活：通过打包的时候使用 -p profile名称指定该profile对应的环境的变量2、属性加载：不同profile定义不同属性或者加载不同的属性文件-代码3.13、属性引用：在2中定义的属性或者加载的属性文件的内容可以通过${定义的属性名称}引用4、属性文件赋值：利用2中加载属性与resource中的filter连用，达到对属性文件赋值的作用，即代码2中的属性文件中所有带有${定义的属性名称}引用的变量，在编译阶段都会用实际的属性代替，代码3.2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051代码3.1&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 默认激活开发配制，使用config-dev.properties来替换设置过虑的资源文件中的$&#123;key&#125; --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-dev.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-test.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;config-prod.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;mysql.username&gt;mysql&lt;/mysql.username&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;``` ``` xml*** 代码3.2-这里filtering属性=true代表所有资源文件中带有placehoder的变量都会用maven的便来给你代替 ***&lt;resources&gt; &lt;!-- Resource Filter --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 4. maven中如何使用resource打不同的资源文件来解决不同环境问题 默认属性文件目录处理：根据profile属性拼接并打包对应的配置文件如代码4.1 源文件目录下配置文件处理：拷贝java源文件目录下的配置文件 1234567891011121314151617181920212223代码4.1&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;excludes&gt; &lt;exclude&gt;application.properties&lt;/exclude&gt; &lt;exclude&gt;application-dev.properties&lt;/exclude&gt; &lt;exclude&gt;application-test.properties&lt;/exclude&gt; &lt;exclude&gt;application-prod.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;application.properties&lt;/include&gt; &lt;include&gt;application-$&#123;profiles.active&#125;.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt;&lt;/resources&gt; 123456789101112131415161718192021代码4.2&lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，只处理如下配置中包含的资源类型 --&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，不处理如下配置中包含的资源类型（剔除下如下配置中包含的资源类型）--&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.yaml&lt;/exclude&gt; &lt;/excludes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，指定处理后的资源文件输出目录，默认是$&#123;build.outputDirectory&#125;指定的目录--&gt; &lt;!--&lt;targetPath&gt;$&#123;build.outputDirectory&#125;&lt;/targetPath&gt; --&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，是否对主资源目录开启资源过滤 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; 4. maven中父子项目依赖关系父子项目依赖的多模块处理作用: 复杂项目通过合理拆分达到代码复用、方便管理 父项目设置-如代码4.1 packaging=pommodules中包含所有子项目，里面的名字为各个项目的artifactId参数 子项目设置-如代码4.2，里面的参数为父项目的相应值，子项目不指定groupId，会自动从父项目中继承 子项目之家可以通过dependency来进行引用 123456789代码4.1&lt;packaging&gt;pom&lt;/packaging&gt;&lt;modules&gt; &lt;module&gt;pojo&lt;/module&gt; &lt;module&gt;web&lt;/module&gt; &lt;module&gt;dao&lt;/module&gt; &lt;module&gt;service&lt;/module&gt;&lt;/modules&gt; 123456代码4.2&lt;parent&gt; &lt;artifactId&gt;online_retailers&lt;/artifactId&gt; &lt;groupId&gt;com.hd&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 5.maven中必要节点的作用说明 filters：定义指定filter属性的位置，例如filter元素赋值filters/filter1.properties,那么这个文件里面就可以定义name=value对，这个name=value对的值就可以在工程pom中通过${name}引用，默认的filter目录是${basedir}/src/main/fiters/ packing：主要打什么类型的包-pom、jar(默认)、war pom - 父类型都为pom jar - 内部调用或者服务使用 war - 部署的项目 modelVersion:模型版本，暂时固定为4.0.0 groupId： 1 项目构建的时候第一次会根据这个参数构建目录2 打包后jar位置为：repository后面的目录为-groupId所设置的目录 、在后面为artifactId，在后面为版本version ，所以groupId+artifactId+version决定了jar包的位置 artifactId：项目的唯一ID version：版本号，分release和snapshot版本 name:项目的显示名称，idea的maven视图中会显示这个名称 6. maven中内置的属性变量内置属性(Maven预定义,用户可以直接使用) ${basedir}表示项目根目录,即包含pom.xml文件的目录; ${version}表示项目版本; ${project.basedir}同${basedir}; ${project.baseUri}表示项目文件地址; ${maven.build.timestamp}表示项目构件开始时间; POM属性 ${project.build.directory}表示主源码路径 ${project.build.sourceEncoding}表示主源码的编码格式 ${project.build.sourceDirectory}表示主源码路径 ${project.build.finalName}表示输出文件名称 ${project.version}表示项目版本,与${version}相同 Java系统属性(所有的Java系统属性都可以使用Maven属性引用) 使用mvn help:system命令可查看所有的Java系统属性; System.getProperties()可得到所有的Java属性; ${user.home}表示用户目录 环境变量属性(所有的环境变量都可以用以env.开头的Maven属性引用) -使用mvn help:system命令可查看所有环境变量; ${env.JAVA_HOME}表示JAVA_HOME环境变量的值; 8.maven的生命周期，以及执行规则1） 生命周期 Maven有三个独立的生命周期为：clean-项目清理、default-项目构建、site-站点生成 2）生命周期对应的阶段clean生命周期包含三个阶段 pre-clean：执行一些需要在clean之前完成的工作 clean：移除所有上一次构建生成的文件 post-clean：执行一些需要在clean之后立刻完成的工作 default生命周期的阶段列表： validate：验证 initialize：initialize build state, e.g. set properties or create directories. generate-sources：generate any source code for inclusion in compilation. process-sources：process the source code, for example to filter any values. generate-resources：处理资源文件 process-resources：复制并处理资源文件，至目标目录，准备打包 compile：编译项目源代码 process-classes：post-process the generated files from compilation, for example to do bytecode enhancement on Java classes. generate-test-sources：generate any test source code for inclusion in compilation. process-test-sources：process the test source code, for example to filter any values. generate-test-resources create resources for testing. process-test-resources 复制并处理资源文件，至目标测试目录 test-compile 编译测试源代码 process-test-classes： post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above. test：使用合适的单元测试框架运行测试，这些测试代码不会被打包或者部署。 prepare-package：perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above) package：接受编译好的代码，打包成可发布的格式，如jar pre-integration-test：perform actions required before integration tests are executed. This may involve things such as setting up the required environment. integration-test：process and deploy the package if necessary into an environment where integration tests can be run. post-integration-test：perform actions required after integration tests have been executed. This may including cleaning up the environment. verify run any checks to verify the package is valid and meets quality criteria. install：将包安装至本地仓库，以让其他项目依赖 deploy 3) 生命周期中阶段的执行关系 某个特定生命周期中，生命周期后面的阶段执行，都会伴随着前面阶段的执行 不同生命周期之间不依赖 4）生命周期、阶段、插件关系一个生命周期中有多个阶段，一个阶段可以绑定一个或者多个插件 9.SNAPSHOT版本和release版本区别 Release版本则代表稳定的版本 只要版本不变，则打包的时候会用本地库中的版本，不会去远程服务器上更新。 Snapshot版本代表不稳定、尚处于开发中的版本 项目每次构建的时候，Maven会去远程repository下载snapshot的最新版本，如果被依赖的snapshot版本不断更新，则项目每次构建的时候的结果都会不一样 10.依赖包的scope取值说明 compile，缺省值，适用于所有阶段，会随着项目一起发布。 provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 11.自定义属性使用标签“properties”中定义的属性","categories":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/categories/MAVEN/"}],"tags":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://tonywang1.github.io/tags/MAVEN/"}]},{"title":"cron使用","slug":"2019/09/24/CRON学习","date":"2019-09-17T20:28:36.000Z","updated":"2019-09-25T06:21:48.816Z","comments":true,"path":"2019/09/18/linux_cron/","link":"","permalink":"https://tonywang1.github.io/2019/09/18/linux_cron/","excerpt":"","text":"CRON使用 1.什么是cron表达式 Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式 2 基本语法corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份 3 基本语法中字段含义 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 年(可选，留空)（Year） 1970~2099 , - * / 四个字符 （1）*：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。 （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。 （3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 （4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. （5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 （6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 （7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 （8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 （9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 4 常用样例（1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业（3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点（5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时（6）0 0 12 ? * WED 表示每个星期三中午12点（7）0 0 12 * * ? 每天中午12点触发（8）0 15 10 ? * * 每天上午10:15触发（9）0 15 10 * * ? 每天上午10:15触发（10）0 15 10 * * ? * 每天上午10:15触发（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发（14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发（18）0 15 10 15 * ? 每月15日上午10:15触发（19）0 15 10 L * ? 每月最后一日的上午10:15触发（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发（23）*/5 * * * * ? 每5秒执行一次（24）0 */1 * * * ? 每隔一分钟执行一次（25）0 1 * * * ? 每个小时的1分钟执行一次，如1点1分、2点1分（26）0 0 1 * * ? 每天零晨1点执行（26）0 0 2 * * ? 每天零晨2点执行（27）0 0 1 20 * ? 每个月20日零晨1点执行","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/categories/LINUX/"}],"tags":[{"name":"LINUX","slug":"LINUX","permalink":"https://tonywang1.github.io/tags/LINUX/"},{"name":"CRON","slug":"CRON","permalink":"https://tonywang1.github.io/tags/CRON/"}]},{"title":"深入字节","slug":"深入字节","date":"2019-09-10T20:32:15.000Z","updated":"2019-09-17T07:36:10.853Z","comments":true,"path":"2019/09/11/lean_byte/","link":"","permalink":"https://tonywang1.github.io/2019/09/11/lean_byte/","excerpt":"","text":"深入了解字节 1.为什么要写字节这个东东 做JAVA项目的时候总会碰到读写字节的过程 经常有字符串和字节互相转化的过程 每次只是知道怎么做，但是不知道为什么这样做 希望经过这篇文章整理，彻底了解这个字节以及字节和用户输入文字之间的关系。 2. 了解一下具体什么是字节 在编程的时候总会遇到字节数组，如读取一个文件时候多个字节一起读、Socket的网络编程的时候读取数据也是按照字节读取的，总会思考这个字节是什么？ 答案：字节实际上就是我们在换算单位时候用到的byte，一个byte=8位（八个0、1组成的一串二进制的数字） 3. 在java中字符串是如何转化为字节的计算机起源美国 -&gt; 美国使用英语 -&gt; 英语（数字、大小写字母、控制字符标点符号、运算字符等组成） -&gt; 8位二进制数（共255个）表示所有字符即：你每次输入一个字符-计算机会到对照表中查找对应的值(二进制、十进制) -&gt; 二进制就可以被计算机识别到此计算机可以识别人类输入的所有英文字符 -&gt; 即字符到二进制的转换 问题出现 -&gt; 非英语字符通过对照表找不到对应的值，就不能识别如何处理对应的字符，如：输入中文“您”，到对照表中找不到，计算机就不认识。那么，就需要有其他的对照表出现：即gb2312、gbk、utf-8等 一个中文转换成字符的过程是怎么样子的？ 字符：‘我’-utf-8编码-&gt;BDE4-&gt;251059（十进制）-&gt;6211（十六进制）-&gt; 1100111011010010 (二进制) ‘中’-&gt;对应的Unicode表的值4E2D（十六进制）（java使用Unicode编码）-&gt;对应的二进制100111000101101-&gt;utf-8填充规则转换-&gt;11100100 10111000 10101101 UTF-8最多可用到6个字节则二进制变为100 111000 101101一共3个部分参考链接 4. 对于计算机的深入思考计算机终究只认识两个东西0、1,但是计算机要处理的是人类的输入并且最后要输出的东西也是要给人类使用的，这时候计算机要处理以下问题 接受人类输入的文字 把字符转化为自己能识别的0和1 对转化过的数据进行二进制之间的计算 对最终的计算结果进行编码成为用户可见的文字并呈现给使用者 其中把人类输入文字转换为0和1,和最终转换为用户可见的文字过程需要使用字符编码 解码:计算机识别的对应编码的二进制数字，按照编码格式转化为统一的编码格式，然后到编码表中找到对应的文字 编码：文字根据编码表找到对应的数值，然后转换为UNIQUE编码的二进制，在转换为工程对应的编码的二进制格式数据","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"一次读取配置文件的探究","slug":"2019/09/09/属性文件读取问题","date":"2019-09-09T17:51:03.000Z","updated":"2019-09-10T12:16:35.565Z","comments":true,"path":"2019/09/10/read_config/","link":"","permalink":"https://tonywang1.github.io/2019/09/10/read_config/","excerpt":"","text":"一次读取配置文件的探究 1. 问题的获取 用App.class.getResourceAsStream(fileName)找不到配置文件，然后去看了一遍源码，发现App.class.getClassLoader().getResourceAsStream代码是有区别的，整理如下： 2. class.getResourceAsStream(fileName)说明 相对路径：如果fileName不是用“/”开头的，则程序会找到Test这个类对应的目录去查找filename类 绝对路径：如果fileName用“/”开头的，则程序会直接从根目录查找对应的文件去加载 详细可以查看源码Class.java 中方法getResourceAsStream 12具体为Class 中的 getResourceAsStream中的方法可以查看详细：resolveName(name) 3.classLoader.getResourceAsStream() 是从类的根目录查找对应的文件，与当前的类路径无关 class中读取配置文件的方法也调用的这个方法 寻找资源文件的时候调用ClassLoader中方法getResource查找 具体查找文件方式为类加载器的双亲委托机制 4. ClassLoader查找文件规则双亲委托模型相关 从根类加载器关联的路径找对应的文件1根类加载器对应的文件路径：String bootClassPath = System.getProperty(&quot;sun.boot.class.path&quot;); 2 . 从扩展类加载器查找文件 1扩展类加载器对应路径：System.out.println(&quot;ext:&quot;+System.getProperty(&quot;java.ext.dirs&quot;)); 3 . 从应用类加载器-这部分包括我们自己项目的目录下所有的jar包和文件 1System.out.println(&quot;app:&quot;+System.getProperty(&quot;java.class.path&quot;)); 5. 那么三种加载器的属性文件在哪里设置的呢？ 所有系统属性可以通过下面的代码获取到，但是具体在什么地方设置的一直没有找到，留到以后探究吧。 1打印java所有的系统环境变量：java.util.Properties properties = System.getProperties();","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://tonywang1.github.io/tags/JAVA/"}]},{"title":"Github上创建自己的网站","slug":"2019/08/30/Github创建网站","date":"2019-08-30T17:51:03.000Z","updated":"2019-11-18T12:53:26.415Z","comments":true,"path":"2019/08/31/gen_github_page/","link":"","permalink":"https://tonywang1.github.io/2019/08/31/gen_github_page/","excerpt":"","text":"Github搭建自己的博客 为什么要搭建自己的博客 探索未知世界 记录自己的成长 为后来者提供借鉴 梳理自己的逻辑思维 整理自己的学习知识，方便以后查阅 1. github page是什么？ GitHub页面是一种静态网站托管服务，旨在直接从GitHub存储库托管个人、组织或项目页面。 Github Page官方详细 2. hexo是什么？ 简单、快速、强大的Node.js静态博客框架 hexo源码 hexo官方网站 3. github page的设置 设置GitHubPage 个人操作借鉴 （详细请参考上文超链接） 创建一个repository，名称为（用户名 + .github.io ）括号中的以后是你博客的默认域名 切换tab到setting，并设置Repository name 4. nodejs、hexo安装，git安装nodejs的安装，直接百度就可以搜索到，直接下载安装非常简单git安装hexo安装参考 5. 创建、清理、发布、启动服务、本地访问文档地址 创建静态站点 hexo init 创建一个文章 hexo new [layout] &lt;title&gt; 生成静态文件 hexo generate 启动服务 hexo server 部署网站 hexo deploy 清除缓存和生成的静态文件 hexo clean 项目本地启动以后可以访问 http://localhost:4000/ 当我们写新的博客发布流程为我上面标号：2 、6、4、5 6. 步骤5中创建的项目与Git关联并上传到git仓库 git init git add . git commit &#39;评论&#39; 本地项目关联到git上：git remote add origin &lt;server&gt; 7. 更换主题 到 主题源码 页面fork源码到我们自己git上 主题安装 点击查看文档 修改配置文件（_config.yml）添加 theme: indigo指定主题 我用的indigo主题源码 8. hexo选择修改语言类型 现在项目还是英文的，需要修改项目的语言为中文 修改配置文件（_config.yml）中 language: zh-CN 6. hexo布局的使用 scaffolds文件夹中有3个文件分别为draft.md、page.md、post.md分别对应草稿、page格式、post格式的文件模板 命令 hexo new [layout] &lt;title&gt; 中的layout取值为：draft、page、post 三个文件中的Front-matter中可以放一些变量在里面，以便生成静态页面的时候可以使用 12345678这里是我自己搭建项目的模板 其中urlname这个变量设置以后生成的静态文件路径上会使用---title: &#123;&#123; title &#125;&#125;urlname: date: &#123;&#123; date &#125;&#125;tags:categories:--- 7. hexo生成静态页面的目录的设置配置文件_config.yml中设置下面的permalink参数，生成静态页面的访问路径，会根据Front-matter中的变量设置参数permalink: :year/:month/:day/:urlname/ 8. hexo标签和分类的使用，以及标签和分类区别分类生成及使用 打开命令行，进入博客所在文件夹。执行命令hexo new page categories 会生成一个文件 ，/categories/index.md 修改分类中的设置如下，有的版本使用type有的版本使用layout变量 1234567---title: 文章分类date: 2019-08-29 15:48:13comments: falsetype: categorieslayout: categories--- 写文章的收需要加上 categories: “文章标签名称” 原理：hexo 会找到layout: categories的设置，然后搜索所有文章中有categories设置的分类，生成分类列表 标签生成及使用操作： 打开命令行，进入博客所在文件夹。执行命令`hexo new page tags 下面的设置和categories一样了","categories":[{"name":"Github","slug":"Github","permalink":"https://tonywang1.github.io/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://tonywang1.github.io/tags/Github/"}]},{"title":"test1","slug":"test1","date":"2019-08-29T10:28:45.000Z","updated":"2019-08-29T02:28:45.788Z","comments":true,"path":"2019/08/29/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/29/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"test10","slug":"2019-8-29/test10","date":"2019-08-29T10:27:50.000Z","updated":"2019-08-30T06:28:44.938Z","comments":true,"path":"2019/08/29/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/29/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-28T07:50:32.729Z","updated":"2019-08-28T07:50:32.729Z","comments":true,"path":"2019/08/28/index/","link":"","permalink":"https://tonywang1.github.io/2019/08/28/index/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}