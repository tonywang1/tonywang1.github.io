---

layout: post
title: java网络编程模型
category: 技术
tags: Java
keywords: JAVA network

---

## 前言 ##

从Netty开始，笔者开始了解java nio，进而发现编程语言提供的功能不过是内核的延伸，而linux内核提供了多种网络通信模型。

## IO基础

### 用户空间和内核空间

为了保证操作系统的稳定性和安全性。用户程序不可以直接访问硬件资源，如果用户程序需要访问硬件资源，必须调用操作系统提供的接口，这个调用接口的过程也就是系统调用。每一次系统调用都会存在两个内存空间之间的相互切换，通常的网络传输也是一次系统调用，通过网络传输的数据先是从内核空间接收到远程主机的数据，然后再**从内核空间复制到用户空间**，供用户程序使用。这种从内核空间到用户空间的数据复制很费时，虽然保住了程序运行的安全性和稳定性，但是牺牲了一部分的效率。

如何分配用户空间和内核空间的比例也是一个问题，是更多地分配给用户空间供用户程序使用，还是首先保住内核有足够的空间来运行。在当前的Windows 32位操作系统中，默认用户空间：内核空间的比例是1:1，而在32位Linux系统中的默认比例是3:1（3GB用户空间、1GB内核空间）（这里只是地址空间，映射到物理地址，可没有某个物理地址的内存只能存储内核态数据或用户态数据的说法）。

## linux0.11内核文件读取的过程


1. 应用程序调用系统调用read（包含文件路径等参数），进入内核态。
2. 内核根据文件路径找到对应的设备号和磁盘数据块。（磁盘的索引块事先会被加载到内存）
3. 先申请一个缓冲区块，将磁盘数据块挂到缓冲区块上（如果该缓冲区块已存在，就算了），进程挂起（直到缓冲块数据到位）。
4. 将缓冲区块挂接到一个请求项上（struct request）。（该struct描述了请求细节：将某个设备的某数据块读到内存的某个缓冲区块上）
5. 将请求项挂到该设备的请求队列上
6. 该设备处理这个请求项时，根据设备号和块设备struct（预先初始化过），找到该设备的请求项处理函数
7. 请求项处理函数取出该设备请求项队列的队首请求项，根据请求项的内容（操作什么设备，读还是写操作，操作那个部分，此处以读操作为例）给设备下达指令（将相应数据发送到指定端口），并将读盘服务程序与硬盘中断操作程序挂接。
8. 硬盘读取完毕后发生中断，硬盘中断程序除进行常规操作（将数据读出到相应寄存器端口）外，调用先前挂接到这里的读盘服务程序
9. 读盘服务程序将硬盘放在数据寄存器端口的数据复制到请求项指定的缓冲块中，并根据数据是否读取完毕（根据请求项内容判断），决定是否停止读取。
10. 如果读取完毕，唤醒因为缓冲块挂起的进程。否则，继续读取。

上述叙述主要涉及了内核态操作，并不完全妥当，但整体感觉是有了。缓冲区读取完毕后，内核随即把数据从内核空间的临时缓冲区拷贝到进程执行read()调用时指定的缓冲区。


## 网络编程模型

socket是什么？怎样理解socket和tcp/ip的关系？

“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口，比如create、listen、connect、accept、send、read和write等等。这个就像操作系统会提供标准的编程接口(比如win32编程接口)，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。java提供的socket、inputstream或者socketchannel等类，本质上也是为了**映射**这些底层的api”

linux支持的网络通信模型

1. 阻塞式io模型        （对应java bio）
2. 非阻塞式io模型
3. io复用模型        
4. 信号驱动io模型
5. 异步io（对应java aio）

对于一开始就学java socket的人来说，千万不要以为io操作必定会引起阻塞。linux内核提供很多模型，只是上层语言是否提供支持的问题（java是在1.4版本后才通过nio库的方式支持io复用模型和非阻塞模型）。并且，nio中关于Pipe、Channel、Buffer和Selector等概念并不是java首创，而是linux内核本身就提供支持的。

## 各个通信模型的特点

各个模型的不同，**主要**体现在read和write系统调用（accept也可以算上）的行为上。

### 阻塞式io模型

以执行read系统调用为例，执行read系统调用会引起线程阻塞，读取完毕后，read返回。
    
### 非阻塞式io模型

read调用会立即返回，只是返回的不一定是数据，还有可能是一个错误号（表示请求数据还未到达）。线程执行到这里会循环查询read状态，类似于`while(true){cas operation}`,没有被阻塞，但也“过不去read”。


关于阻塞式io和非阻塞式io，说的是执行read/write系统调用时的行为，可以在socket选项中配置，比如在java nio中，可以使用`SocketChannel.configureBlocking(false)`设置使用非阻塞式io。
    
### io复用模型

在linux中，一切设备皆文件，故socket也可以用文件描述符fd来表示。

linux提供select系统调用监听（多个）fd的状态，当某个fd就绪时，通知我们处理。
    
    1. // 传入需要监控的描述符，readfds表示一个fd集合，你只关心这些fd是否可读
    2. int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    3. // 如果某个fd可读，select会更改其状态
    4. 遍历readfds{
    5.     如果fd可读{   
    6.         //将读取的数据复制到缓冲区，read立即返回，一定是可以读到数据的，但数据不一定完整
    7.         read(fd,已定义的缓冲区,xx)   
    8.         // 处理逻辑
    9.     }
    10. }
        
        
linux同时提供epoll系统调用，也是监听fd的状态。
    
    1. epoll_create(xxx)
    // 将事件（比如可读）与fd绑定到一起，当数据到达时，内核会执行一个与读取事件相关的（回调）函数，找到绑定的fd并更改其状态
    2. epoll_ctl(xx,fd,事件,xx,..)
    // 在给定时间内，收集发生的事件
    3. 发生的事件个数 = epoll_wait(xx，发生的事件集合,xx)
    4. for(i=0;i<事件发生的个数;i++){
        // 根据该"事件"结构，可以拿到相应的fd
        // read(fd,已定义的缓冲区,xx)   
    }
        
select 和 epoll 主要区别是，select轮询所有fd（如果监控的fd过多，轮询一次挺费劲的），select发现fd就绪时（比如可读、可写等），由select更改fd的状态。epoll则是注册fd（与某个事件绑定），当事件发生时，由内核更改fd的状态。epoll其实应用了观察者模式，内核知道数据什么时候到达，在数据处理逻辑外，执行实现注册的“回调”函数。epoll还相对select进行了其它很多优化措施。

io复用模型跟阻塞或非阻塞io没什么关系，前者阻塞select调用上，后者阻塞（或“卡在”）在read或write调用上。使用io复用模型，并不影响读写数据时使用阻塞或非阻塞io，甚至包括下面的异步io。

### 异步io

    // 这表示通知内核读取数据，并立即返回
    1. 执行read系统调用（同时传一个缓冲区和回调函数）。
    // 内核发现数据到达，处理相关逻辑，将数据从内核复制到自定义的缓冲区，执行回调函数
    

io复用和异步io的不同之处是：

不管是select还是epoll模型，都会专门弄一个线程监听fd的状态，fd就绪时，执行read，read系统调用执行时，肯定是可以读到数据的，只是数据不一定完整。而对于异步io模型，read系统调用执行时，可能数据还未接收，read调用的作用只是告诉内核（注册一个函数到某个位置），数据过来的时候放到哪里，怎么处理，剩下的由内核执行（内核读取数据后，从特定地点拿到注册的函数并执行）。

同步（说的不是多线程中的synchronized）指的是代码要一步一步执行。异步可以在没有执行完当前这行代码之前，就执行下一行代码。

## 伪异步io模型

在java支持异步io模型前，为了解决阻塞io的性能问题，或者说破解“一个请求必须占用一个线程”的缺点，人们想了很多办法，比如使用线程池。

当收到一个请求时，将请求暂存到队列中，线程池中的线程依次取出“请求”并执行，这种方式有以下优点：

- 网络通信占用的线程数是可控的
- 使用线程池，省掉了线程创建和销毁的时间

优化效果的达成，功劳主要来自线程模型的改变。换句话说，线程分为io线程和计算线程，对于io线程，对于不同的io模型，如何使用合适的线程模型，是一个重要的问题，也是我们学习一个io框架（比如netty）要搞清楚的核心问题。
## 小结

本文对各个网络模型进行了介绍和对比，如果错误，欢迎大家指正。

## 引用

[IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）](http://blog.csdn.net/historyasamirror/article/details/5778378)


